package dbms.util;

import java.io.Serializable;
import java.util.LinkedList;

import dbms.Main;
import dbms.bplus.PrimaryBPlusTree;
import dbms.bplus.Reference;
import dbms.bplus.SecondaryBPlusTree;
import dbms.exececution.EnormousCharacterException;
import dbms.exececution.EnormousRecordException;
import dbms.exececution.InvalidPrimaryKeyException;
import dbms.parser.SQLTokens;

/**
 * Describes the table as it is declared in our DBMS. It contains the name of the table,
 * the columns that contain the fields and the primary key.
 */
public class Table implements Serializable {

	/**
	 * The autogenerated serial version UID.
	 */
	private static final long serialVersionUID = 5325920569737049121L;

	/**
	 * The names of the columns. 
	 */
	private String[] columnNames;

	/**
	 * The names of the secondary indexes.
	 */
	private String[] indexNames;

	/**
	 * The types of the column.
	 */
	private SQLTokens[] columnTypes;

	/**
	 * The filename of the table.
	 */
	private String filename;

	/**
	 * The index of the primary key.
	 */
	private int indexOfPrimaryKey;

	/**
	 * The name of the table.
	 */
	private String name;

	/**
	 * The primary index.
	 */
	private PrimaryBPlusTree primaryIndex;

	/**
	 * The secondary indexes.
	 */
	private SecondaryBPlusTree[] secondaryIndexes;

	/**
	 * The fields size.
	 */
	private int fieldsSize;

	/**
	 * Creates a table by assigning the name, the columns and the primary key to
	 * the appropriate fields using the parameters given.
	 * 
	 * @param name
	 *            The name.
	 * @param columns
	 *            The columns.
	 * @param primaryKey
	 *            The primary key.
	 */
	public Table(String name, Object[] columns, String primaryKey)
			throws InvalidPrimaryKeyException, EnormousRecordException {
		this.name = name;
		this.columnNames = new String[columns.length];
		this.columnTypes = new SQLTokens[columns.length];
		this.indexOfPrimaryKey = -1;

		for (int i = 0; i < columns.length; i++) {
			columnNames[i] = (String) ((Object[]) columns[i])[0];
			if (columnNames[i].equals(primaryKey)) {
				this.indexOfPrimaryKey = i;
			}
			columnTypes[i] = (SQLTokens) ((Object[]) columns[i])[1];
		}
		if (indexOfPrimaryKey < 0) {
			throw new InvalidPrimaryKeyException(primaryKey);
		}
		if (columnTypes[indexOfPrimaryKey] != SQLTokens.INTEGER) {
			throw new InvalidPrimaryKeyException(SQLTokens.INTEGER.toString());
		}

		Object[] emptyFields = new Object[columnNames.length];
		this.fieldsSize = 0; // taken from record
		for (int i = 0; i < emptyFields.length; i++) {
			if (columnTypes[i] == SQLTokens.INTEGER) {
				emptyFields[i] = new Integer(Integer.MIN_VALUE);
				this.fieldsSize += 4;
			} else if (columnTypes[i] == SQLTokens.CHAR)// check if already
			// checked
			{
				try {
					emptyFields[i] = new Char("");
				} catch (EnormousCharacterException e) {
					System.err.println("Fatal Error....Call the admin!");
				}
				this.fieldsSize += 100;
			}
		}
		if (fieldsSize + 9 > Page.getUtilePageSize(dbms.Main.PAGE_SIZE))
			throw new EnormousRecordException(
					"Too big record size!!Please choose less columns!!");

		this.indexNames = new String[columns.length];
		this.secondaryIndexes = new SecondaryBPlusTree[columns.length];
		this.primaryIndex = new PrimaryBPlusTree(Page
				.getUtilePageSize(dbms.Main.PAGE_SIZE)
				/ fieldsSize, new Record(emptyFields, fieldsSize));
		this.filename = name + ".tbl";
	}

	/**
	 * Adds a secondary index over a column.
	 * 
	 * @param columnIndex
	 *            The column index.
	 * @param newIndex
	 *            The new index.
	 */
	public void addSecondaryIndex(int columnIndex, SecondaryBPlusTree newIndex) {
		this.indexNames[columnIndex] = newIndex.getName();
		this.secondaryIndexes[columnIndex] = newIndex;
	}

	/**
	 * @param index
	 *            The index for column type.
	 * @return The column type.
	 */
	public SQLTokens getColumnType(int index) {
		return columnTypes[index];
	}

	/**
	 * Returns the number of columns.
	 * 
	 * @return The number of columns.
	 */
	public int getNumberOfColumns() {
		return columnTypes.length;
	}

	/**
	 * Returns the primary index.
	 * 
	 * @return The primary index.
	 */
	public PrimaryBPlusTree getPrimaryIndex() {
		return primaryIndex;
	}

	/**
	 * Returns the field size.
	 * 
	 * @return The field size.
	 */
	public int getFieldsSize() {
		return fieldsSize;
	}

	/**
	 * Returns the name of table.
	 * 
	 * @return the name
	 */
	public String getName() {
		return name;
	}

	/**
	 * Checks if the column has an index or not.
	 * 
	 * @param columnIndex
	 *            The index of the desired column.
	 * @return <code>true</code> if the column has an index and
	 *         <code>false</code> otherwise.
	 */
	public boolean hasIndex(int columnIndex) {
		return indexOfPrimaryKey == columnIndex
				|| secondaryIndexes[columnIndex] != null;
	}

	/**
	 * Retrieves the index of a column.
	 * 
	 * @param column
	 *            The column's name.
	 * @return The index of the column.
	 */
	public int indexOfColumn(String column) {
		int index = -1;
		for (int i = 0; i < columnNames.length; i++) {
			if (columnNames[i].equals(column)) {
				index = i;
				break;
			}
		}
		return index;
	}


	/**
	 * Removes a secondary index.
	 * 
	 * @param indexName
	 *            The name of the index.
	 * @return True if the index was removed.
	 */
	public boolean removeSecondaryIndex(String indexName) {
		for (int i = 0; i < columnNames.length; i++) {
			if (this.indexNames[i] != null
					&& this.indexNames[i].equals(indexName)) {
				secondaryIndexes[i] = null;
				this.indexNames[i] = null;
				return true;
			}
		}
		return false;
	}

	/**
	 * Overrides the <code>toString method</code>.
	 * 
	 * @return The string.
	 */
	public String toString() {
		String toReturn = "Table: " + name + "\nFile: " + filename;
		for (int i = 0; i < columnNames.length; i++) {
			toReturn += "\nColumn: " + columnNames[i] + " Type: "
					+ columnTypes[i];
		}
		toReturn += "\nPrimary Key: " + columnNames[indexOfPrimaryKey];
		return toReturn;
	}

	/**
	 * It inserts a new record to the table. If it fails it returns a failure
	 * message.
	 * 
	 * @param newRecord
	 *            The record to be inserted.
	 * @return <code>true</code> if the record was inserted
	 *         <code>false</code> otherwise.
	 */
	public boolean insertRecord(Record newRecord)
	{
		Object[] result = primaryIndex.insert(newRecord);
		if ((Boolean) result[0])
		{
			for (int i = 0; i < secondaryIndexes.length; i++)
			{
				if (secondaryIndexes[i] == null)
					continue;
				secondaryIndexes[i].insert(new Reference((Integer) newRecord
						.getKey(secondaryIndexes[i].getKeyIndex()),
						(Integer) result[1], (Integer) result[2]));
			}
			return true;
		}
		else
		{
			System.err.println("The primary key already exists!");
			return false;
		}

	}


	/**
	 * It deletes the records having the <code>value</code>.
	 * 
	 * @param value
	 *            The value of the victim.
	 * @param columnIndex
	 *            The column index of the victim
	 */
	public void deleteRecords(Char value, int columnIndex) {
		Object[] result = this.primaryIndex.delete(value.toString(),
				columnIndex);
		if (!(Boolean) result[0]) {
			return;
		}
		for (int i = 0; i < secondaryIndexes.length; i++) {
			if (secondaryIndexes[i] == null)
				continue;
			secondaryIndexes[i].delete((LinkedList<Object[]>) result[1]);
		}
		Main.exe.updateSecondaryIndexes((LinkedList<Record>) result[2],
				(LinkedList<Reference>) result[3],
				(LinkedList<Reference>) result[4]);
	}

	/**
	 * It deletes records whose values are satisfying the operation that was executed on them.
	 * 
	 * @param columnIndex
	 *            The index of the column.
	 * @param operator
	 *            The operator.
	 * @param value
	 *            The value.
	 */
	public void deleteRecords(int columnIndex, SQLTokens operator, Integer value) {
		Object[] result = null;
		if (columnIndex == this.indexOfPrimaryKey) {
			switch (operator) {
			case GREATER:
				result = primaryIndex.deleteAllGreaterOrEqual(value + 1);
				break;
			case GREATER_OR_EQUAL:
				result = primaryIndex.deleteAllGreaterOrEqual(value);
				break;
			case LESS:
				result = primaryIndex.deleteAllLessOrEqual(value - 1);
				break;
			case LESS_OR_EQUAL:
				result = primaryIndex.deleteAllLessOrEqual(value);
				break;
			case EQUAL:
				result = primaryIndex.delete(value);
				break;
			default:
				break;
			}
			if (!(Boolean) result[0]) {
				return;
			}
			for (int i = 0; i < secondaryIndexes.length; i++) {
				if (secondaryIndexes[i] == null)
					continue;
				secondaryIndexes[i].delete((LinkedList<Object[]>) result[1]);
			}
			Main.exe.updateSecondaryIndexes((LinkedList<Record>) result[2],
					(LinkedList<Reference>) result[3],
					(LinkedList<Reference>) result[4]);
		} else if (secondaryIndexes[columnIndex] != null) {
			switch (operator) {
			case GREATER:
				result = secondaryIndexes[columnIndex]
						.deleteAllGreaterOrEqual(value + 1);
				break;
			case GREATER_OR_EQUAL:
				result = secondaryIndexes[columnIndex]
						.deleteAllGreaterOrEqual(value);
				break;
			case LESS:
				result = secondaryIndexes[columnIndex]
						.deleteAllLessOrEqual(value - 1);
				break;
			case LESS_OR_EQUAL:
				result = secondaryIndexes[columnIndex]
						.deleteAllLessOrEqual(value);
				break;
			case EQUAL:
				result = secondaryIndexes[columnIndex].delete(value);
				break;
			default:
				break;
			}
			if (!(Boolean) result[0]) {
				return;
			}
			result = primaryIndex.delete((LinkedList<Reference>) result[1]);
			if (!(Boolean) result[0]) {
				return;
			}
			for (int i = 0; i < secondaryIndexes.length; i++) {
				if (secondaryIndexes[i] == null || i == columnIndex)
					continue;
				secondaryIndexes[i].delete((LinkedList<Object[]>) result[1]);
			}
			Main.exe.updateSecondaryIndexes((LinkedList<Record>) result[2],
					(LinkedList<Reference>) result[3],
					(LinkedList<Reference>) result[4]);
		} else {
			switch (operator) {
			case GREATER:
				result = primaryIndex.deleteAllGreater(value, columnIndex);
				break;
			case GREATER_OR_EQUAL:
				result = primaryIndex.deleteAllGreater(value - 1, columnIndex);
				break;
			case LESS:
				result = primaryIndex.deleteAllLess(value, columnIndex);
				break;
			case LESS_OR_EQUAL:
				result = primaryIndex.deleteAllLess(value + 1, columnIndex);
				break;
			case EQUAL:
				result = primaryIndex.delete(value, columnIndex);
				break;
			default:
				break;
			}
			if (!(Boolean) result[0]) {
				return;
			}
			for (int i = 0; i < secondaryIndexes.length; i++) {
				if (secondaryIndexes[i] == null)
					continue;
				secondaryIndexes[i].delete((LinkedList<Object[]>) result[1]);
			}
			Main.exe.updateSecondaryIndexes((LinkedList<Record>) result[2],
					(LinkedList<Reference>) result[3],
					(LinkedList<Reference>) result[4]);
		}
	}

	/**
	 * Retrieves the index of the primary key.
	 * 
	 * @return The <code>indexOfPrimaryKey</code>.
	 */
	public int getIndexOfPrimaryKey() {
		return indexOfPrimaryKey;
	}

	/**
	 * Retrieves the secondary index in a column of a table.
	 * 
	 * @param columnIndex
	 *            The index of the column.
	 * @return The secondary index
	 */
	public SecondaryBPlusTree getSecondaryIndex(final int columnIndex) {
		return this.secondaryIndexes[columnIndex];
	}

	/**
	 * Retrieves all the results.
	 * 
	 * @return All the results
	 */
	public LinkedList getAll() {
		Object[] results = primaryIndex
				.findAllGreaterOrEqual(Integer.MIN_VALUE);
		return (LinkedList<Record>) results[1];
	}

	/**
	 * Finds the records that were found in the column <code>columnIndex</code>
	 * and have the value <code>value</code>.
	 * 
	 * @param value
	 *            The desired value.
	 * @param columnIndex
	 *            The desired column index.
	 * @return The records found.
	 */
	public LinkedList<Record> find(Char value, int columnIndex) {
		Object[] results = primaryIndex.find(value.toString(), columnIndex);
		return (LinkedList<Record>) results[1];
	}

	/**
	 * Finds records that satisfy the condition that the operation and the value
	 * describe.
	 * 
	 * @param columnIndex
	 *            The index of the column.
	 * @param operator
	 *            The operator.
	 * @param value
	 *            The desired value.
	 * @return a list of records
	 */
	public LinkedList<Record> find(int columnIndex, SQLTokens operator,
			Integer value) {
		Object[] result = null;
		if (columnIndex == this.indexOfPrimaryKey) {
			switch (operator) {
			case GREATER:
				result = primaryIndex.findAllGreaterOrEqual(value + 1);
				break;
			case GREATER_OR_EQUAL:
				result = primaryIndex.findAllGreaterOrEqual(value);
				break;
			case LESS:
				result = primaryIndex.findAllLessOrEqual(value - 1);
				break;
			case LESS_OR_EQUAL:
				result = primaryIndex.findAllLessOrEqual(value);
				break;
			case EQUAL:
				result = primaryIndex.find(value);
				break;
			default:
				break;
			}
			if (!(Boolean) result[0]) {
				return (LinkedList<Record>) result[1];
			}
		} else if (secondaryIndexes[columnIndex] != null) {
			switch (operator) {
			case GREATER:
				result = secondaryIndexes[columnIndex]
						.findAllGreaterOrEqual(value + 1);
				break;
			case GREATER_OR_EQUAL:
				result = secondaryIndexes[columnIndex]
						.findAllGreaterOrEqual(value);
				break;
			case LESS:
				result = secondaryIndexes[columnIndex]
						.findAllLessOrEqual(value - 1);
				break;
			case LESS_OR_EQUAL:
				result = secondaryIndexes[columnIndex]
						.findAllLessOrEqual(value);
				break;
			case EQUAL:
				result = secondaryIndexes[columnIndex].find(value);
				break;
			default:
				break;
			}
			if (!(Boolean) result[0]) {
				return (LinkedList<Record>) result[1];
			}
			result = primaryIndex.find((LinkedList<Reference>) result[1]);
			if (!(Boolean) result[0]) {
				System.err.println();
				return (LinkedList<Record>) result[1];
			}
		} else {
			switch (operator) {
			case GREATER:
				result = primaryIndex.findAllGreater(value, columnIndex);
				break;
			case GREATER_OR_EQUAL:
				result = primaryIndex.findAllGreater(value - 1, columnIndex);
				break;
			case LESS:
				result = primaryIndex.findAllLess(value, columnIndex);
				break;
			case LESS_OR_EQUAL:
				result = primaryIndex.findAllLess(value + 1, columnIndex);
				break;
			case EQUAL:
				result = primaryIndex.find(value, columnIndex);
				break;
			default:
				break;
			}
			if (!(Boolean) result[0]) {
				return (LinkedList<Record>) result[1];
			}
		}
		return (LinkedList<Record>) result[1];
	}

	/**
	 * Finds a list of records whose keys are inside a range of values.
	 * 
	 * @param columnIndex
	 *            The index of the column.
	 * @param lowValue
	 *            The lower limit.
	 * @param highValue
	 *            The upper limit.
	 * @return A list of records
	 */
	public LinkedList findRange(int columnIndex, Integer lowValue,
			Integer highValue) {
		Object[] result = null;
		if (columnIndex == indexOfPrimaryKey) {
			result = primaryIndex.findAllInRange(lowValue, highValue);
			if (!(Boolean) result[0]) {
				return (LinkedList<Record>) result[1];
			}
		} else {
			result = primaryIndex.findAllInRange(lowValue, highValue,
					columnIndex);
			if (!(Boolean) result[0]) {
				return (LinkedList<Record>) result[1];
			}
		}
		return (LinkedList<Record>) result[1];
	}

}
