package dbms.bplus;

import java.io.Serializable;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;

import dbms.util.DiskHandler;
import dbms.util.Page;
import dbms.util.Record;

/**
 * Implemenents a B+ Tree that is being used as a secondary index in our DBMS
 * System.
 */
public class SecondaryBPlusTree implements Serializable {
	/**
	 * The autogenerated serial version UID number.
	 */
	private static final long serialVersionUID = -3067354847061997555L;

	/**
	 * The root node.
	 */
	private Node root;

	/**
	 * The first leaf (<code>SecondaryLeaf</code>) of our B+ Tree.
	 */
	private SecondaryLeaf firstLeaf;

	/**
	 * The bucket factor.
	 */
	private final int bucketFactor;

	/**
	 * The ceiling of the <code>bucketFactor</code> divided by 2. It is used to
	 * define the minimum number of children a node can have in the B+ Tree.
	 */
	private final int bucketFactorDiv2;

	/**
	 * The key index.
	 */
	private final int keyIndex;

	/**
	 * The name.
	 */
	@SuppressWarnings("unused")
	private final String name;

	/**
	 * Creates the secondary B+ tree by assigning values to the <code>bucketFactor</code>
	 * field taken from the primary B+ Tree, the <code>keyIndex</code>
	 * and the <code>name</code> fields with values taken from the parameters.
	 * 
	 * @param keyIndex
	 *            The key index.
	 * @param primaryTree
	 *            The primary tree (index).
	 * @param name
	 *            The name.
	 */
	@SuppressWarnings("unchecked")
	public SecondaryBPlusTree(final int keyIndex,
			final PrimaryBPlusTree primaryTree, final String name) {
		this.bucketFactor = primaryTree.getBucketFactor();
		this.bucketFactorDiv2 = (int) Math.ceil((double) bucketFactor / 2);

		this.keyIndex = keyIndex;
		this.name = name;

		// Δημιουργία αναφορών προς τις εγγραφές του πρωτεύοντος δενδρου.
		LinkedList<Reference> references = this.createReferences(keyIndex,
				primaryTree);

		if (references.size() == 0) {
			this.firstLeaf = new SecondaryLeaf(this.bucketFactor);
			this.root = this.firstLeaf;
			return;
		} // end if

		// Ταξινόμηση των αναφορών βάσει του κλειδιού καθεμίας εξ αυτών.
		Collections.sort(references, new Comparator<Reference>() {
			public int compare(Reference firstReference,
					Reference secondReference) {
				if (firstReference.getKey() < secondReference.getKey())
					return -1;
				else if (firstReference.getKey() > secondReference.getKey())
					return 1;
				else
					return 0;
			}
		});

		// Γέμισμα των φύλλων με τις αναφορές.
		LinkedList<SecondaryLeaf> allLeaves = this.fillLeaves(references);

		if (allLeaves.size() == 1) {
			this.firstLeaf = allLeaves.get(0);
			this.root = this.firstLeaf;
			return;
		} // end if

		InnerNode currentNode = new InnerNode(this.bucketFactor);

		// Αναδόμηση του δένδρου ξεκινώντας απ' τα φύλλα προς τη ρίζα.
		InnerNode newNode;
		int key;
		while (allLeaves.size() > 0) {
			// Ο εσωτερικός κόμβος γεμίζει με κλειδιά μέχρι να υπερχειλίσει ή
			// να μην υπάρχουν άλλα κλειδιά για να πάρει.
			this.fillInnerNode(currentNode, allLeaves);

			if (currentNode.getParent() == null) {
				this.root = currentNode;
			} // end if

			if (currentNode.isReplete()) {
				// Διάσπαση του κόμβου και ανέβασμα του μεσαίου κλειδιού
				// στον κόμβο - γονέα.
				key = currentNode.removeKey(this.bucketFactorDiv2 - 1);

				newNode = this.splitInnerNode(currentNode);

				if (currentNode.getParent() == null) {
					// Δημιουργία νέου γονέα, ο οποίος θα βρίσκεται στη ρίζα.
					this.createNewParent(currentNode, newNode, key);
				} // end if
				else {
					// Αναδόμηση των εσωτερικών κόμβων (μέχρι τη ρίζα αν
					// χρειαστεί).
					this.reconstructInnerNodes(key, currentNode, newNode);
				} // end else

				currentNode = newNode;
			} // end if
			else if (currentNode.getNumOfKeys() < this.bucketFactorDiv2
					&& !(currentNode == this.root)) {
				// Επειδή ο κόμβος δεν έχει αρκετά στοιχεία βρίσκει τον αριστερό
				// γείτονα του και παίρνει απ' αυτόν κλειδία - παιδιά. Είναι
				// σίγουρο ότι ο γείτονας αυτός είναι πλήρως συμπληρωμένος, άρα
				// έχει στοιχεία για να δώσει.

				// Ο κόμβος που εξετάζουμε είναι σίγουρα το τελευταίο παιδί του
				// γονέα, άρα εύκολα βρίσκουμε τον αριστερό του γείτονα.
				int index = currentNode.getParent().getNumOfKeys() - 2;
				InnerNode neighbourNode = (InnerNode) currentNode.getParent()
						.getChild(index);

				// Μεταφορά κλειδιών και παιδιών.
				while (currentNode.getNumOfKeys() < this.bucketFactorDiv2) {
					key = neighbourNode
							.removeKey(neighbourNode.getNumOfKeys() - 1);

					newNode = (InnerNode) neighbourNode
							.removeChild(neighbourNode.getNumOfKeys());

					currentNode.addFirst(key, newNode);
				} // end while
			} // end else
		}// end while
	} // end method SecondaryBPlusTree

	/**
	 * Creates references to the primary B+ tree which serves as the primary
	 * index.
	 * 
	 * @param keyIndex
	 *            The key index.
	 * @param primaryTree
	 *            The primary tree(index).
	 * @return The references created.
	 */
	private LinkedList<Reference> createReferences(final int keyIndex,
			final PrimaryBPlusTree primaryTree) {
		LinkedList<Reference> allReferences = new LinkedList<Reference>();

		PrimaryLeaf leaf = primaryTree.getFirstLeaf();

		Page page;
		Reference reference;
		do {
			// Φόρτωση της κατάλληλης σελίδας στη μνήμη.
			page = DiskHandler.loadPage(leaf.getPageNumber(), primaryTree
					.getBucketFactor(), primaryTree.getEmptyRecordCopy());

			// Δημιουργία αναφορών για την τρέχουσα σελίδα.

			// Μόλις βρεθεί η πρώτη <<νεκρή>> εγγραφή σταματά η
			// δημιουργία αναφορών (για τη σελίδα αυτή), διότι
			// γνωρίζουμε ότι όλες οι επόμενες εγγραφές είναι
			// <<νεκρές>>.
			int i = 0;
			while (i < page.getPageLength() && !page.getRecord(i).isDead()) {
				// Δημιουργία αναφοράς για την τρέχουσα <<μη νεκρή>> εγγραφή.
				reference = new Reference((Integer) page.getRecord(i).getKey(
						keyIndex), leaf.getPageNumber(), i);

				// Προσθήκη στη δομή των αναφορών.
				allReferences.add(reference);

				i++;
			} // end for

			leaf = leaf.getRightLeaf();
		} // end do
		while (leaf != null);

		return allReferences;
	} // end method createReferences

	/**
	 * Fills the leaves using the references that have been previously created.
	 * 
	 * @param references
	 *            The references to the primary tree.
	 * @return A <code>LinkedList</code> of the <code>SecondaryLeaf</code> created.
	 */
	private LinkedList<SecondaryLeaf> fillLeaves(
			final LinkedList<Reference> references) {
		// Ο παρακάτω κώδικας περιέχει πολλές επαναλήψεις αλλά είναι φτιαγμένος
		// για την ταχύτερη εκτέλεση.

		LinkedList<SecondaryLeaf> allLeaves = new LinkedList<SecondaryLeaf>();

		if (references.size() < this.bucketFactor) {
			// Γέμισμα των φύλλων με όσες αναφορές έχουν απομείνει.
			LinkedList<Reference> newLeafReferences = new LinkedList<Reference>(
					references.subList(0, references.size()));

			SecondaryLeaf leaf = new SecondaryLeaf(this.bucketFactor,
					newLeafReferences);

			// Συλλογή των φύλλων σε μια δομή.
			allLeaves.add(leaf);
			return allLeaves;
		} // end if

		// Γέμισμα των φύλλων με πλήθος αναφορών ίσο με bucketFactor.
		LinkedList<Reference> newLeafReferences = new LinkedList<Reference>(
				references.subList(0, this.bucketFactor));

		SecondaryLeaf leaf = new SecondaryLeaf(this.bucketFactor,
				newLeafReferences);

		// Συλλογή των φύλλων σε μια δομή.
		allLeaves.add(leaf);

		// Ο παρακάτω βρόγχος περιέχει τον ίδιο κώδικα, αλλά περιέχει
		// επιπλέον κώδικα για την ενημέρωση των δεικτών.

		int lowerIndex = this.bucketFactor;
		int upperIndex = 2 * this.bucketFactor;
		while (upperIndex < references.size()) {
			// Γέμισμα των φύλλων με πλήθος αναφορών ίσο με bucketFactor.
			newLeafReferences = new LinkedList<Reference>(references.subList(
					lowerIndex, upperIndex));

			leaf = new SecondaryLeaf(this.bucketFactor, newLeafReferences);

			// Συλλογή των φύλλων σε μια δομή.
			allLeaves.add(leaf);

			// Ενημέρωση των δεικτών των φύλλων.
			allLeaves.get(allLeaves.size() - 2).setRightLeaf(leaf);
			leaf.setLeftLeaf(allLeaves.get(allLeaves.size() - 2));

			lowerIndex = upperIndex;
			upperIndex += this.bucketFactor;
		} // end while
		if (lowerIndex < references.size()) {
			// Γέμισμα των φύλλων με πλήθος με όσες αναφορές απομένουν.
			newLeafReferences = new LinkedList<Reference>(references.subList(
					lowerIndex, references.size()));

			leaf = new SecondaryLeaf(this.bucketFactor, newLeafReferences);

			// Συλλογή των φύλλων σε μια δομή.
			allLeaves.add(leaf);

			// Ενημέρωση των δεικτών των φύλλων.
			allLeaves.get(allLeaves.size() - 2).setRightLeaf(leaf);
			leaf.setLeftLeaf(allLeaves.get(allLeaves.size() - 2));
		} // end if

		return allLeaves;
	} // end method fillLeaves

	/**
	 * Fills a node with the leaves previously created until the node is
	 * replete.
	 * 
	 * @param node
	 *            The inner node.
	 * @param allLeaves
	 *            The list with all the leaves created.
	 */
	private void fillInnerNode(final InnerNode node,
			final LinkedList<SecondaryLeaf> allLeaves) {
		SecondaryLeaf child;
		// Ο κόμβος γεμίζει με κλειδιά (και παιδιά) μέχρι να υπερχειλίσει!
		for (int i = 0; !node.isReplete() && allLeaves.size() > 1; i++) {
			child = allLeaves.remove(0);
			child.setParent(node);

			node.addLast(child.getLastReference().getKey(), child);
		} // end for

		// Για τη μεταφορά ν κλειδιών πρέπει να μεταφερθούν ν + 1 παιδιά.
		// Έτσι εδώ μεταφέρουμε ένα παιδί αλλά όχι ένα κλειδί.
		child = allLeaves.remove(0);
		child.setParent(node);
		node.addLastChild(child);
	} // end method fillInnerNode

	/**
	 * Creates a new parent node if there are orphan node(s).
	 * 
	 * @param firstChild
	 *            The first child.
	 * @param secondChild
	 *            The second child.
	 * @param key
	 *            Parent's key.
	 */
	private void createNewParent(final Node firstChild, final Node secondChild,
			final int key) {
		// Ο νέος γονέας γίνεται ρίζα.
		InnerNode parent = new InnerNode(this.bucketFactor);
		this.root = parent;

		// Ενημέρωση δεικτών.
		firstChild.setParent(parent);
		secondChild.setParent(parent);

		// Εισαγωγή κλειδιού - παιδιών στον νέο γονέα.
		parent.addFirst(key, firstChild);
		parent.addLastChild(secondChild);
	} // end method createNewParent

	/**
	 * Reconstructs inner nodes after new nodes have been created (perhaps from
	 * a split procedure). Also checks if replition takes place.
	 * 
	 * @param key
	 *            The current node's key.
	 * @param currentNode
	 *            The current node.
	 * @param newChild
	 *            The new node.
	 */

	private void reconstructInnerNodes(int key, InnerNode currentNode,
			Node newChild) {
		boolean repeat = true;
		while (repeat) {
			// Εισαγωγή κλειδιού στον κόμβο.
			currentNode.insertKey(key, newChild);

			// Έλεγχος υπερχείλισης.
			if (currentNode.isReplete()) {
				// Αφαιρείται το μεσαίο κλειδί...
				key = currentNode.removeKey(this.bucketFactorDiv2);

				// και γίνεται διάσπαση του κόμβου.
				newChild = this.splitInnerNode(currentNode);

				// Έλεγχος γαι την ύπαρξη γονέα.
				if (currentNode.getParent() == null) {
					// Δημιουργία γονέα.
					createNewParent(currentNode, newChild, key);

					// Τερματισμός της αναδόμησης.
					repeat = false;
				} // end if
				else {
					// Ο έλεγχος περνά στον γονέα.
					currentNode = currentNode.getParent();

					// Ενημέρωση δεικτών.
					newChild.setParent(currentNode);
				} // end else
			} // end if
			else {
				// Τερματισμός της αναδόμησης.
				repeat = false;
			} // end else
		} // end while
	} // end method reconstructInnerNodes

	/**
	 * Splits an inner node to two and places <code>bucketFactorDiv2</code> children to the first and
	 * the rest to the second. The parent(s) and the appropriate fields are
	 * updated too.
	 * 
	 * @param currentNode
	 *            The node to be splited.
	 * @return The new InnerNode.
	 */

	private InnerNode splitInnerNode(final InnerNode currentNode) {
		// Έχει προηγηθεί η αφαίρεση του μεσαίου παιδιού του κόμβου!

		Node child;
		InnerNode newNode = new InnerNode(this.bucketFactor);

		// Μεταφορά των μισών στοιχείων σε έναν νέο κόμβο.
		for (int i = this.bucketFactorDiv2 + 1; i < this.bucketFactor; i++) {
			child = currentNode.removeChild(this.bucketFactorDiv2);
			// Αφού ο κόμβος αλλάζει γονέα πρέπει να ενημερωθεί και το
			// αντίστοιχο πεδίο του.
			child.setParent(newNode);
			newNode
					.addLast(currentNode.removeKey(this.bucketFactorDiv2),
							child);
		} // end for

		child = currentNode.removeChild(this.bucketFactorDiv2);
		child.setParent(newNode);
		newNode.addLastChild(child);

		return newNode;
	} // end method splitInnerNode

	/**
	 * Searches for a secondary leaf using its key. When the secondary leaf is
	 * found it is returned.
	 * 
	 * @param key
	 *            The key of the primary leaf-target.
	 * @return The desired <code>SecondaryLeaf</code>.
	 */
	private SecondaryLeaf search(final int key) {
		// Ξεκινώντας απ' τη ρίζα...
		Node currentNode = this.root;

		// διασχίζεται το δένδρο μέχρι να βρεθεί το φύλλο με το ζητούμενο
		// κλειδί.
		int index = 0;
		while (currentNode.getNodeType() == NodeType.INNER_NODE
				&& index <= this.bucketFactor) {
			InnerNode currentInnerNode = (InnerNode) currentNode;
			if (currentInnerNode.isLastKeyEntry(index)
					|| key <= currentInnerNode.getKey(index)) {
				currentNode = currentInnerNode.getChild(index);
				index = 0;
			} // end if
			else {
				// Αν το ζητούμενο κλειδί έχει τιμή μεγαλύτερη απ' αυτή που
				// εξετάζεται, τότε προχωρούμε στην εξέταση της επομένης.
				index++;
			} // end else
		}// end while
		return (SecondaryLeaf) currentNode;
	} // end method search

	/**
	 * Inserts a new record to the appropriate position inside the Secondary B+
	 * Tree.
	 * 
	 * @param reference
	 *            The reference to the leaf that the insertion must take place.
	 */

	public void insert(final Reference reference) {
		// Αναζητείται το φύλλο στο οποίο θα γίνει η εισαγωγή.
		SecondaryLeaf currentLeaf = this.search(reference.getKey());

		// Πραγματοποιείται η εισαγωγή στο φύλλο.
		currentLeaf = currentLeaf.insertReference(reference);

		if (currentLeaf.isReplete()) {
			// Εάν προκύψει υπερχείλιση, τότε γίνεται διάσπαση του φύλλου...
			SecondaryLeaf newNode = this.splitLeaf(currentLeaf);

			// και αναδόμηση του καταλόγου.
			this.reconstructTree(currentLeaf, newNode);
		} // end if
	} // end method insert

	/**
	 * Splits a secondary leaf to two and adjusts the connections of the children-nodes
	 * with their neighbours.
	 * 
	 * @param currentLeaf
	 *            The current secondary leaf.
	 * @return The new leaf.
	 */

	private SecondaryLeaf splitLeaf(final SecondaryLeaf currentLeaf) {
		SecondaryLeaf newLeaf = new SecondaryLeaf(this.bucketFactor);

		// Μεταφορά των μισών αναφορών στο νέο φύλλο.
		for (int i = this.bucketFactorDiv2; i < this.bucketFactor; i++) {
			// Αντιγραφή της εγγραφής στη νέα σελίδα.
			newLeaf.setReferenceLast(currentLeaf.getReference(
					this.bucketFactorDiv2).clone());

			// Διαγραφή της εγγαφής της παλαιάς σελίδας.
			currentLeaf.deleteReference(this.bucketFactorDiv2);
		} // end for

		// Η τελευταία εγγραφή αφαιρείται, χωρίς να αντικατασταθεί από μια κενή.
		// Με αυτό τον τρόπο εξασφαλίζεται ότι η σελίδα περιέχει πλήθος εγγραφών
		// ίσο με bucketFactor.
		newLeaf.setReferenceLast(currentLeaf
				.removeReference(this.bucketFactorDiv2));

		// Ενημέρωση των δεικτών των φύλλων προς τα γειτονικά τους.
		SecondaryLeaf thirdLeaf = currentLeaf.getRightLeaf();

		newLeaf.setRightLeaf(thirdLeaf);
		currentLeaf.setRightLeaf(newLeaf);

		if (thirdLeaf != null) {
			thirdLeaf.setLeftLeaf(newLeaf);
		} // end if
		newLeaf.setLeftLeaf(currentLeaf);

		return newLeaf;
	} // end method splitPage

	/**
	 * Reconstructs the tree in order to adjust it to changes that may have
	 * happened (e.g. after secondary leaf's split).
	 * 
	 * @param currentLeaf
	 *            The current leaf.
	 * @param newLeaf
	 *            The new leaf.
	 */

	private void reconstructTree(final SecondaryLeaf currentLeaf,
			final SecondaryLeaf newLeaf) {
		// Εξέταση έαν υπάρχει γονέας για τον τρέχοντα κόμβο.
		if (currentLeaf.getParent() == null) {
			// Δημιουργία γονέα (τίθεται αυτόματα ρίζα).
			this.createNewParent(currentLeaf, newLeaf, currentLeaf
					.getLastReference().getKey());
		} // end if
		else {
			// Ενημέρωση γονέα και παιδιών.
			InnerNode currentNode = currentLeaf.getParent();

			newLeaf.setParent(currentNode);
			Node newNode = newLeaf;

			// Αναδόμηση του καταλόγου.
			this.reconstructInnerNodes(currentLeaf.getLastReference().getKey(),
					currentNode, newNode);
		} // end else
	} // end method reconstructTree

	/**
	 * Deletes a record (the one with key equal to the one given in the parameter)
	 * and creates references to the elements of the primary tree that must be
	 * deleted.
	 * 
	 * @param secondaryKey
	 *            the desired key
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search.
	 *         <li>A <code>LinkedList</code> object with the references of
	 *         the records that must be deleted.
	 *         </ul>
	 */

	public Object[] delete(final int secondaryKey) {
		// Για διαγραφή ενός δευτερεύοντος κλειδιού - επειδή τα κλειδιά δεν
		// είναι μονοδικά μπορεί να διαγραφούν περισσότερες της μιας αναφορές.

		Object[] result = new Object[2];
		LinkedList<Reference> deleted = new LinkedList<Reference>();

		// Αναζητείται το φύλλο απ' το οποίο θα ξεκινήσουν οι διαγραφές του
		// κλειδιού - εάν υπάρχει το κλειδί αυτό.
		SecondaryLeaf leaf = this.search(secondaryKey);

		// Η διαγραφή μπορεί να επεκταθεί σε περισσότερα του ενός φύλλα.
		boolean stop = false;
		int index;
		while (leaf != null && !stop) {
			index = 0;
			while (index < leaf.getNumOfReferences()) {
				if (leaf.getReference(index).getKey() == secondaryKey) {
					// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
					// διαγραφεί απ' τον πρωτεύοντα κατάλογο.
					deleted.add(leaf.getReference(index));

					// Διαγραφή της αναφοράς.
					leaf.deleteReference(index);
				} // end if
				else if (leaf.getReference(index).getKey() > secondaryKey) {
					// Εάν επιτύχει αυτός ο έλεγχος σημαίνει είτε ότι το κλειδί
					// δεν υπάρχει είτε ότι όσα κλειδιά έπρεπε να διαγραφούν
					// διαγράφηκαν, οπότε δεν χρειάζεται να ερευνήσουμε τις
					// υπόλοιπες αναφορές.
					stop = true;
					break;
				} // end else
				else {
					// Προχωρούμε στην επόμενη αναφορά.
					index++;
				} // end else
			} // end for

			// Εξετάζουμε το επόμένο φύλλο.
			leaf = leaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής και μια λίστα
		// με τις αναφορές των εγγραφών που πρέπει να διαγραφούν.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;

		return result;
	} // end method delete

	/**
	 * Same as the <code>delete</code> method except here we delete all the
	 * records with key greater or equal to the one given to the parameter.
	 * 
	 * @param secondaryKey
	 *            The desired key.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search
	 *         <li>A <code>LinkedList</code> object with the references of
	 *         the records that must be deleted.
	 *         </ul>
	 */

	public Object[] deleteAllGreaterOrEqual(final int secondaryKey) {
		// Για διαγραφή όλων των δευτερευόντων κλειδιών με τιμή μεγαλύτερη ή ίση
		// απ' αυτή που δόθηκε.

		Object[] result = new Object[2];
		LinkedList<Reference> deleted = new LinkedList<Reference>();

		// Αναζήτηση του φύλλου που αναφέρεται σε αυτό το κλειδί.
		SecondaryLeaf leaf = this.search(secondaryKey);

		// Επειδή τα κλειδιά είναι ταξινομημένα, βρίσκουμε το κλειδί που μας
		// ενδιαφέρει...
		int index = 0;
		while (index < leaf.getNumOfReferences()
				&& leaf.getReference(index).getKey() < secondaryKey) {
			// Εάν η αναφορά δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index++;
		} // end while

		// και στη συνέχεια διαγράφουμε αυτό και όσα βρίσκονται δεξιά απ' αυτό.
		for (int i = leaf.getNumOfReferences() - 1; i > index - 1; i--) {
			// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
			// διαγραφεί απ' τον πρωτεύοντα κατάλογο.
			deleted.add(leaf.getReference(i));

			// Διαγραφή της αναφοράς.
			leaf.deleteReference(i);
		} // end for

		// Μετά διαγράφουμε όλες τις αναφορές σε όλα τα φύλλα που βρίσκονται
		// δεξιά της προηγουμένης.
		leaf = leaf.getRightLeaf();

		while (leaf != null) {
			for (int i = leaf.getNumOfReferences() - 1; i > -1; i--) {
				// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
				// διαγραφεί απ' τον πρωτεύοντα κατάλογο.
				deleted.add(leaf.getReference(i));

				// Διαγραφή της αναφοράς.
				leaf.deleteReference(i);
			} // end for

			// Εξετάζουμε το επόμένο φύλλο.
			leaf = leaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής και μια λίστα
		// με τις αναφορές των εγγραφών που πρέπει να διαγραφούν.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;

		return result;
	} // end method deleteAllGreaterOrEqual

	/**
	 * Same as the <code>delete</code> method except that it deletes all the records
	 * with keys less or equal to <code>secondaryKey/</code>.
	 * 
	 * @param secondaryKey
	 *            Tthe desired key.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search.
	 *         <li>A <code>LinkedList</code> object with the references of
	 *         the records that must be deleted.
	 *         </ul>
	 */
	public Object[] deleteAllLessOrEqual(final int secondaryKey) {
		// Για διαγραφή όλων των δευτερευόντων κλειδιών με τιμή μικρότερη ή ίση
		// απ' αυτή που δόθηκε.

		Object[] result = new Object[2];
		LinkedList<Reference> deleted = new LinkedList<Reference>();

		// Αναζήτηση του φύλλου που αναφέρεται σε αυτό το κλειδί.
		SecondaryLeaf leaf = this.search(secondaryKey);

		// Επειδή τα κλειδιά είναι ταξινομημένα, βρίσκουμε το κλειδί που μας
		// ενδιαφέρει...
		int index = leaf.getNumOfReferences() - 1;
		while (index > -1 && leaf.getReference(index).getKey() > secondaryKey) {
			// Εάν η αναφορά δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index--;
		} // end while

		// και στη συνέχεια διαγράφουμε αυτό και όσα βρίσκονται αριστερά απ'
		// αυτό.
		for (int i = index; i > -1; i--) {
			// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
			// διαγραφεί απ' τον πρωτεύοντα κατάλογο.
			deleted.add(leaf.getReference(i));

			// Διαγραφή της αναφοράς.
			leaf.deleteReference(i);
		} // end for

		// Μετά διαγράφουμε όλες τις αναφορές σε όλα τα φύλλα που βρίσκονται
		// αριστερά της προηγουμένης.
		leaf = leaf.getLeftLeaf();
		while (leaf != null) {
			for (int i = leaf.getNumOfReferences() - 1; i > -1; i--) {
				// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
				// διαγραφεί απ' τον πρωτεύοντα κατάλογο.
				deleted.add(leaf.getReference(i));

				// Διαγραφή της αναφοράς.
				leaf.deleteReference(i);
			} // end for

			// Εξετάζουμε το επόμένο φύλλο.
			leaf = leaf.getLeftLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής και μια λίστα
		// με τις αναφορές των εγγραφών που πρέπει να διαγραφούν.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;

		return result;
	} // end method deleteAllLessOrEqual

	/**
	 * It is used to delete records after a deletion made in a primary index.
	 * There is a possibility that we may have a value that spans over multiple leaves.
	 * This method checks these leaves too and if such values exist it deletes them also.
	 * 
	 * @param deleted
	 *            The list with the references that were deleted from the primary
	 *            index.
	 */
	public void delete(final LinkedList<Object[]> deleted) {
		// Για ενημέρωση του δευτερεύοντος καταλόγου μετά από διαγραφή στον
		// πρωτεύοντα κατάλογο.

		// Διαγράφονται οι αναφορές που δείχνουν στις εγγραφές και τις θέσεις
		// που περιέχει η λίστα.

		SecondaryLeaf leaf;
		boolean stop;

		// Για κάθε στοιχείο της λίστας διαγράφουμε την αντίστοιχη αναφορά.
		for (int i = 0; i < deleted.size(); i++) {
			leaf = this.search((Integer) ((Record) deleted.get(i)[0])
					.getKey(this.keyIndex));

			stop = false;

			// Υπάρχει περίπτωση να υπάρχουν πάρα πολλές όμοιες τιμές για το
			// χαρακτηριστικό και να υπάρχει <<διαρροή>> στα διπλανά φύλλα. Έτσι
			// θα πρέπει να τα ελέγξουμε και αυτά, διότι η αναφορά που
			// αναζητούμε μπορεί να βρίσκεται εκεί.
			while (leaf != null && !stop) {
				// Εδώ ελέγχονται όλες οι αναφορές του φύλλου.
				int index = 0;
				while (index < leaf.getNumOfReferences()) {
					if (((Reference) deleted.get(i)[1]).getPageNumber() == leaf
							.getReference(index).getPageNumber()
							&& ((Reference) deleted.get(i)[1]).getOffset() == leaf
									.getReference(index).getOffset()) {
						// Διαγραφή της αναφοράς.
						leaf.deleteReference(index);
						stop = true;
						break;
					} // end if

					// Εάν η αναφορά δεν δείχνει στη σελίδα και στη θέση που
					// θέλουμε, τότε προχωρούμε στην επομένη.
					index++;
				} // end while

				// Ελέγχουμε το επόμενο φύλλο.
				leaf = leaf.getRightLeaf();
			} // end while
		} // end for
	} // end mehtod delete

	/**
	 * Finds a record (the one with secondary key equal to the one given in the
	 * parameter) and returns it.
	 * 
	 * @param secondaryKey
	 *            The desired key.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search process.
	 *         <li>A <code>LinkedList</code> object with the references that
	 *         must be retrieved.
	 *         </ul>
	 */

	public Object[] find(final int secondaryKey) {
		// Για εύρεση ενός δευτερεύοντος κλειδιού - επειδή τα κλειδιά εδώ δεν
		// είναι μονοδικά μπορεί να επιστραφούν περισσότερες της μιας αναφορές.

		Object[] result = new Object[2];
		LinkedList<Reference> selected = new LinkedList<Reference>();

		// Αναζητείται το φύλλο απ' το οποίο θα ξεκινήσουν η προσπάθεια εύρεσης
		// του κλειδιού - εάν υπάρχει το κλειδί αυτό.
		SecondaryLeaf leaf = this.search(secondaryKey);

		// Η προσπάθεια εύρεσης μπορεί να επεκταθεί σε περισσότερα του ενός
		// φύλλα.
		boolean stop = false;
		int index;
		while (leaf != null && !stop) {
			index = 0;
			while (index < leaf.getNumOfReferences()) {
				if (leaf.getReference(index).getKey() == secondaryKey) {
					// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
					// βρεθεί στον πρωτεύοντα κατάλογο.
					selected.add(leaf.getReference(index));
				} // end if
				else if (leaf.getReference(index).getKey() > secondaryKey) {
					// Εάν επιτύχει αυτός ο έλεγχος σημαίνει είτε ότι το κλειδί
					// δεν υπάρχει είτε ότι όσα κλειδιά έπρεπε να βρεθούν
					// βρέθηκαν, οπότε δεν χρειάζεται να ερευνήσουμε τις
					// υπόλοιπες αναφορές.
					stop = true;
					break;
				} // end else

				// Προχωρούμε στην επόμενη αναφορά.
				index++;
			} // end for

			// Εξετάζουμε το επόμένο φύλλο.
			leaf = leaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις αναφορές των εγγραφών που πρέπει να βρεθούν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method find

	/**
	 * Same as the <code>find</code> method except here we search for all the
	 * records with secondary key greater or equal to <code>secondaryKey</code>.
	 * 
	 * @param secondaryKey
	 *            The desired key.
	* @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search process.
	 *         <li>A <code>LinkedList</code> object with the references that
	 *         must be retrieved.
	 *         </ul>
	 */
	 
	public Object[] findAllGreaterOrEqual(final int secondaryKey) {
		// Για εύρεση όλων των δευτερευόντων κλειδιών με τιμή μεγαλύτερη ή ίση
		// απ' αυτή που δόθηκε.

		Object[] result = new Object[2];
		LinkedList<Reference> selected = new LinkedList<Reference>();

		// Αναζήτηση του φύλλου που αναφέρεται σε αυτό το κλειδί.
		SecondaryLeaf leaf = this.search(secondaryKey);

		// Επειδή τα κλειδιά είναι ταξινομημένα, βρίσκουμε το κλειδί που μας
		// ενδιαφέρει...
		int index = 0;
		while (index < leaf.getNumOfReferences()
				&& leaf.getReference(index).getKey() < secondaryKey) {
			// Εάν η αναφορά δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index++;
		} // end while

		// και στη συνέχεια κρατούμε όσα βρίσκονται δεξιά απ' αυτό.
		for (int i = leaf.getNumOfReferences() - 1; i > index - 1; i--) {
			// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
			// βρεθεί στον πρωτεύοντα κατάλογο.
			selected.addFirst(leaf.getReference(i));
		} // end for

		// Μετά κρατούμε όλες τις αναφορές σε όλες τις σελίδες που βρίσκονται
		// δεξιά της προηγουμένης.
		leaf = leaf.getRightLeaf();
		while (leaf != null) {
			for (int i = 0; i < leaf.getNumOfReferences(); i++) {
				// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
				// βρεθεί στον πρωτεύοντα κατάλογο.
				selected.addLast(leaf.getReference(i));
			} // end for

			// Εξετάζουμε το επόμένο φύλλο.
			leaf = leaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις αναφορές των εγγραφών που πρέπει να βρεθούν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllGreaterOrEqual

	/**
	 * Same as the <code>find</code> method except here we search for all the
	 * records with secondary key lesser or equal to <code>secondaryKey</code>
	 * 
	 * @param secondaryKey
	 *            The desired key.
	* @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search process.
	 *         <li>A <code>LinkedList</code> object with the references that
	 *         must be retrieved.
	 *         </ul>
	 */
	public Object[] findAllLessOrEqual(final int secondaryKey) {
		// Για εύρεση όλων των δευτερευόντων κλειδιών με τιμή μικρότερη ή ίση
		// απ' αυτή που δόθηκε.

		Object[] result = new Object[2];
		LinkedList<Reference> selected = new LinkedList<Reference>();

		// Αναζήτηση του φύλλου που αναφέρεται σε αυτό το κλειδί.
		SecondaryLeaf leaf = this.search(secondaryKey);

		// Επειδή τα κλειδιά είναι ταξινομημένα, βρίσκουμε το κλειδί που μας
		// ενδιαφέρει...
		int index = leaf.getNumOfReferences() - 1;
		while (index > -1 && leaf.getReference(index).getKey() > secondaryKey) {
			// Εάν η αναφορά δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index--;
		} // end while

		// και στη συνέχεια κρατούμε όσα βρίσκονται αριστερά απ' αυτό.
		for (int i = index; i > -1; i--) {
			// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
			// βρεθεί στον πρωτεύοντα κατάλογο.
			selected.addFirst(leaf.getReference(i));
		} // end for

		// Μετά κρατούμε όλες τις εγγραφές σε όλες τις σελίδες που βρίσκονται
		// αριστερά της προηγουμένης.
		leaf = leaf.getLeftLeaf();
		while (leaf != null) {
			for (int i = leaf.getNumOfReferences() - 1; i > -1; i--) {
				// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
				// βρεθεί στον πρωτεύοντα κατάλογο.
				selected.addFirst(leaf.getReference(i));
			} // end for

			// Εξετάζουμε το επόμένο φύλλο.
			leaf = leaf.getLeftLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις αναφορές των εγγραφών που πρέπει να βρεθούν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllLessOrEqual

	/**
	 * Same as the <code>find</code> method except that it finds all the records in
	 * the <u>open</u> range between <code>firstSecondaryKey</code> and <code>lastSecondaryKey</code>.
	 * @param firstSecondaryKey
	 *            The first key.
	 * @param lastSecondaryKey
	 *            The last key the index of the key.
	* @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search process.
	 *         <li>A <code>LinkedList</code> object with the references that
	 *         must be retrieved.
	 *         </ul>
	 */
	public Object[] findAllInRange(final int firstSecondaryKey,
			final int lastSecondaryKey) {
		// Για εύρεση όλων των δευτερευόντων κλειδιών με τιμή στο (ανοιχτό)
		// διάστημα που δίδεται.

		Object[] result = new Object[2];
		LinkedList<Reference> selected = new LinkedList<Reference>();

		// Αναζήτηση του φύλλου που αναφέρεται σε αυτό το κλειδί.
		SecondaryLeaf leaf = this.search(firstSecondaryKey);

		// Επειδή τα κλειδιά είναι ταξινομημένα, βρίσκουμε το κλειδί που μας
		// ενδιαφέρει...
		int index = 0;
		while (index < leaf.getNumOfReferences()
				&& leaf.getReference(index).getKey() < firstSecondaryKey) {
			// Εάν η αναφορά δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index++;
		} // end while

		// και στη συνέχεια κρατούμε όσα βρίσκονται δεξιά απ' αυτό.
		for (int i = index + 1; i < leaf.getNumOfReferences(); i++) {
			// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
			// βρεθεί στον πρωτεύοντα κατάλογο.
			selected.add(leaf.getReference(index));
		} // end for

		// Μετά κρατούμε όλες τις αναφορές σε όλες τις σελίδες που βρίσκονται
		// δεξιά της προηγουμένης.
		leaf = leaf.getRightLeaf();

		while (leaf != null) {
			for (int i = 0; i < leaf.getNumOfReferences(); i++) {
				if (leaf.getReference(i).getKey() < lastSecondaryKey) {
					// Αποθηκεύουμε την αναφορά της εγγραφής που θα πρέπει να
					// βρεθεί στον πρωτεύοντα κατάλογο.
					selected.add(leaf.getReference(index));
				} // end if
				else {
					break;
				} // end else
			} // end for

			// Εξετάζουμε το επόμένο φύλλο.
			leaf = leaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις αναφορές των εγγραφών που πρέπει να βρεθούν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllGreater

	/**
	 * It updates the references using the reference lists according to
	 * which the records were moved.
	 * 
	 * @param recordsMoved
	 *            The records that were moved.
	 * @param oldReferenceList
	 *            The list with old references.
	 * @param newReferenceList
	 *            The list with the new references.
	 */
	public void updateReferences(final LinkedList<Record> recordsMoved,
			final LinkedList<Reference> oldReferenceList,
			final LinkedList<Reference> newReferenceList) {
		SecondaryLeaf leaf;
		boolean repeat;

		int index = 0;
		while (index < recordsMoved.size()) {
			repeat = true;

			// Βρίσκουμε το φύλλο στο οποίο βρίσκεται η αναφορά που θα
			// ενημερωθεί.
			leaf = this.search((Integer) recordsMoved.get(index).getKey(
					this.keyIndex));

			while (repeat && leaf != null) {
				for (int i = 0; i < leaf.getNumOfReferences(); i++) {
					if (leaf.getReference(i).getPageNumber() == oldReferenceList
							.get(index).getPageNumber()
							&& leaf.getReference(i).getOffset() == oldReferenceList
									.get(index).getOffset()) {
						// Ενημερώνεται η αναφορά για τη μετακίνηση της εγγραφής
						// στην οποία αντιστοιχεί.
						leaf.changePageAndOffset(i, newReferenceList.get(index)
								.getPageNumber(), newReferenceList.get(index)
								.getOffset());

						// Προχωρούμε στο επόμενο στοιχείο των λιστών.
						index++;

						// Σταματούμε την αναζήτηση.
						repeat = false;
						break;
					} // end if
				} // end for

				// Προχωρούμε στο επόμενο φύλλο.
				leaf = leaf.getRightLeaf();
			} // end while
		} // end while
	} // end method updateReferences

	/**
	 * Retrieves the first leaf
	 * 
	 * @return The first <code>PrimaryLeaf</code>.
	 */
	public SecondaryLeaf getFirstLeaf() {
		return this.firstLeaf;
	} // end method getFirstLeaf
	/**
	 * Retrieves the key index
	 * 
	 * @return The key index.
	 */
	public int getKeyIndex() {
		return this.keyIndex;
	} // end method getKeyIndex

	/**
	* Retrieves the name.
	 * 
	 * @return The name.
	 */
	public String getName() {
		return this.name;
	} // end getName
} // end class SecondaryBPlusTree
