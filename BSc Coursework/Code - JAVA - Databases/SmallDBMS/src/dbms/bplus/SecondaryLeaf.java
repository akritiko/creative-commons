package dbms.bplus;

import java.io.Serializable;
import java.util.LinkedList;

/**
 * Implements a leaf which is going to be used by a <code>SecondaryBPlusTree</code>.
 */
public class SecondaryLeaf extends Node implements Serializable {
	/**
	 * The autogenerated serialVersionUID.
	 */
	private static final long serialVersionUID = 3861302277789026743L;

	/**
	 * The list of references for this leaf.
	 */
	private LinkedList<Reference> references;

	/**
	 * The index of the position inside <code>references</code> to which the
	 * next reference is going to be placed.
	 */
	private int indexOfNextReferenceToBeFilled;

	/**
	 * The right leaf of this leaf.
	 */
	private SecondaryLeaf rightLeaf;

	/**
	 * The left leaf of this leaf.
	 */
	private SecondaryLeaf leftLeaf;

	/**
	 * The bucket factor.
	 */
	private final int bucketFactor;

	/**
	 * Creates a secondary leaf (we don't have the reference list). It
	 * initializes the reference list by placing dead references equal to
	 * <code>bucketFactor</code> parameter. Then it assigns the
	 * <code>bucketFactor</code> parameter's value to the
	 * <code>bucketFactor</code> field and initializes all other fields with
	 * the default values.
	 * 
	 * @param bucketFactor
	 *            The bucket factor's value.
	 */
	public SecondaryLeaf(final int bucketFactor) {
		super(NodeType.SECONDARY_LEAF);

		this.references = new LinkedList<Reference>();
		for (int i = 0; i < bucketFactor; i++) {
			this.references.add(i, new Reference());
		} // end for

		this.indexOfNextReferenceToBeFilled = 0;

		this.leftLeaf = null;
		this.rightLeaf = null;

		this.bucketFactor = bucketFactor;
	} // end method SecondaryLeaf

	/**
	 * Creates a secondary leaf (we do have the reference list). It initializes
	 * the reference list from the <code>references</code> parameter. Then it
	 * assigns the <code>bucketFactor</code> parameter's value to the
	 * <code>bucketFactor</code> field, the size of <code>references</code>
	 * parameter to the <code>indexOfNextReferenceToBeFilled</code> field and
	 * initializes all other fields with the default values.
	 * 
	 * @param bucketFactor
	 *            The bucket factor's value.
	 * @param references A LinkedList of references.
	 */
	public SecondaryLeaf(final int bucketFactor,
			final LinkedList<Reference> references) {
		super(NodeType.SECONDARY_LEAF);

		this.references = references;

		// Το φύλλο πρέπει οπωσδήποτε να έχει πλήθος αναφορών ίσο με
		// bucketFactor, οπότε γεμίζουμε το φύλλο με όσες <<νεκρές>>
		// εγγραφές χρειάζεται.
		if (references.size() < this.bucketFactor) {
			for (int i = references.size(); i < this.bucketFactor; i++) {
				this.references.add(i, new Reference());
			} // end for
		} // end if

		this.indexOfNextReferenceToBeFilled = references.size();

		this.leftLeaf = null;
		this.rightLeaf = null;

		this.bucketFactor = bucketFactor;
	} // end method SecondaryLeaf

	/**
	 * Retrieves the reference with index <code>index</code>.
	 * 
	 * @param index
	 *            The index of the reference we want to retrieve.
	 * @return The <code>Reference</code> at <code>index</code>
	 */
	public Reference getReference(final int index) {
		return this.references.get(index);
	} // end method getReference

	/**
	 * Retrieves the last reference.
	 * 
	 * @return The last <code>Reference</code>.
	 */
	public Reference getLastReference() {
		return this.references.get(this.indexOfNextReferenceToBeFilled - 1);
	} // end method getLastReference

	/**
	 * It inserts a reference to the reference list <code>References</code>.
	 * 
	 * @param newReference
	 *            The new reference.
	 * @return The <code>SecandaryLeaf</code> to which the reference was
	 *         inserted.
	 */
	public SecondaryLeaf insertReference(final Reference newReference) {
		SecondaryLeaf leaf = this;
		boolean repeat;

		do {
			repeat = false;

			int i;
			for (i = 0; i < leaf.references.size(); i++) {
				if (leaf.references.get(i).isDead()) {
					leaf.references.set(i, newReference);
					leaf.indexOfNextReferenceToBeFilled++;
					break;
				} // end if
				else if (newReference.getKey() < leaf.references.get(i)
						.getKey()) {
					leaf.references.add(i, newReference);
					leaf.indexOfNextReferenceToBeFilled++;

					// Εάν γίνει εισαγωγή τότε είναι σίγουρο ότι θα προκληθεί
					// υπερχείλιση. Εάν το τελευταίο στοιχείο είναι <<νεκρό>>,
					// τότε αφαιρείται.
					if (leaf.isReplete() && leaf.references.getLast().isDead()) {
						leaf.references.removeLast();
					} // end if
					break;
				} // end else if
			} // end for

			// Εδώ εξετάζεται εάν θα επιχειρηθεί η εισαγωγή στο επόμενο φύλλο.
			if (i == leaf.references.size()) {
				if (leaf.rightLeaf == null) {
					// Εάν επιτύχει ο παραπάνω έλεγχος, τότε η αναφορά θα
					// εισαχθεί στο παρόν φύλλο, προκαλώντας έτσι την
					// υπερχείλιση του!
					leaf.references.addLast(newReference);
					leaf.indexOfNextReferenceToBeFilled++;
				} // end if
				else {
					leaf = leaf.rightLeaf;
					repeat = true;
				} // end else
			} // end if
		} // end do
		while (repeat);

		// Ενημερώνεται ο γονέας.
		if (leaf.getParent() != null) {
			// Βρίσκουμε τη θέση του παιδιού στον κόμβο - γονέα.
			int childIndex = leaf.getParent().findIndexOfChild(leaf);

			// Εάν είναι το τελευταίο παιδί δεν αντισοιχίζεται με κάποιο κλειδί
			// στον κόμβο - γονέα.
			if (!(leaf.getParent().getNumOfKeys() == childIndex)) {
				// Αλλάζουμε το κλειδί στη θέση αυτή.
				leaf.getParent().setKey(childIndex,
						leaf.getLastReference().getKey());
			} // end if
		} // end if

		return leaf;
	} // end method insertReference

	/**
	 * Changes the values of <code>page</code> and <code>offset</code>
	 * fields.
	 * 
	 * @param index
	 *            The index of the leaf-target.
	 * @param page
	 *            The new page value.
	 * @param offset
	 *            The new offset value.
	 */
	public void changePageAndOffset(final int index, final int page,
			final int offset) {
		this.references.get(index).changePageAndOffset(page, offset);
	} // end method changePageAndOffset

	/**
	 * Replaces the last reference with <code>newReference</code>.
	 * 
	 * @param newReference
	 *            The new <code>Reference</code>.
	 */
	public void setReferenceLast(final Reference newReference) {
		this.references.set(this.indexOfNextReferenceToBeFilled, newReference);
		this.indexOfNextReferenceToBeFilled++;
	} // end method setRecordLast

	/**
	 * Makes the reference with <code>index</code> a dead reference and
	 * moves it to the last position of the reference list.
	 * 
	 * @param index
	 *            The index of the reference-target.
	 */
	public void deleteReference(final int index) {
		// Κατά την διαγραφή η εγγραφή <<σκοτώνεται>> και στη συνέχεια
		// τοποθετείται στο τέλος. Έτσι διατηρείται η διάταξη των εγγραφών.
		this.references.get(index).killReference();
		this.references.addLast(this.references.remove(index));
		this.indexOfNextReferenceToBeFilled--;
	} // end method deleteReference

	/**
	 * Removes the reference with index <code>index</code> from the list.
	 * 
	 * @param index
	 *            The index of the reference-target.
	 * @return The removed reference.
	 */
	public Reference removeReference(final int index) {
		this.indexOfNextReferenceToBeFilled--;
		return this.references.remove(index);
	} // end method removeReference

	/**
	 * Retrieves the number of references that the secondary leaf has.
	 * 
	 * @return The number of references.
	 */
	public int getNumOfReferences() {
		return this.indexOfNextReferenceToBeFilled;
	}// end method getNumOfReferences

	/**
	 * Retrieves the left leaf of this leaf.
	 * 
	 * @return the <code>SecondaryLeaf leftLeaf</code> of this leaf
	 */
	public SecondaryLeaf getLeftLeaf() {
		return this.leftLeaf;
	} // end method getLeftLeaf

	/**
	 * Assigns the value of the parameter <code>leftLeaf</code> to the
	 * <code>leftLeaf</code> field.
	 * 
	 * @param leftLeaf
	 *            The new <code>leftLeaf</code>.
	 */
	public void setLeftLeaf(final SecondaryLeaf leftLeaf) {
		this.leftLeaf = leftLeaf;
	} // end method setLeftLeaf

	/**
	 * Retrieves the right leaf of this leaf.
	 * 
	 * @return The <code>SecondaryLeaf rightLeaf</code> of the current leaf.
	 */
	public SecondaryLeaf getRightLeaf() {
		return this.rightLeaf;
	} // end method getRightLeaf

	/**
	 * Assigns the value of the parameter <code>rightLeaf</code> to the
	 * <code>rightLeaf</code> field.
	 * 
	 * @param rightLeaf
	 *            The new <code>rightLeaf</code>.
	 */
	public void setRightLeaf(final SecondaryLeaf rightLeaf) {
		this.rightLeaf = rightLeaf;
	} // end method setRightLeaf
	/**
	 * Checks if the secondary leaf is replete or not.
	 * 
	 * @return <code>true</code> if the inner node is replete and
	 *         <code>false</code> otherwise.
	 */
	public boolean isReplete() {
		return this.references.size() > this.bucketFactor;
	} // end method isReplete
} // end class SecondaryLeaf
