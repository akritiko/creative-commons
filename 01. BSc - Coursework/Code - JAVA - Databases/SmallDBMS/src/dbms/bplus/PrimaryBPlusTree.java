package dbms.bplus;

import java.io.Serializable;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;

import dbms.Main;
import dbms.util.Char;
import dbms.util.DiskHandler;
import dbms.util.Page;
import dbms.util.Record;

/**
 * Implemenents a B+ Tree that is being used as a primary index in our DBMS
 * System.
 */
public class PrimaryBPlusTree implements Serializable {
	/**
	 * The autogenerated serial version UID number.
	 */
	private static final long serialVersionUID = 8202754705755998606L;

	/**
	 * The root node.
	 */
	private Node root;

	/**
	 * The first leaf <code>PrimaryLeaf</code> of our B+ Tree.
	 */
	private PrimaryLeaf firstLeaf;

	/**
	 * The bucket factor.
	 */
	private final int bucketFactor;

	/**
	 * The ceiling of the number of bucket factor divided by 2. It is used to
	 * define the maximum number of children a node in our B+ tree can have.
	 */
	private final int bucketFactorDiv2;

	/**
	 * The next page number.
	 */
	private int nextPageNumber;

	/**
	 * An empty record.
	 */
	private final Record emptyRecord;

	/**
	 * Creates the primary B+ tree by assigning the bucket factor and an
	 * empty record taken from parameters and making the <code>root</code> and
	 * <code>first leaf</code> point at the same node.
	 * 
	 * @param bucketFactor
	 *            The bucket factor.
	 * @param emptyRecord
	 *            An empty record.
	 */
	public PrimaryBPlusTree(final int bucketFactor, final Record emptyRecord) {
		this.bucketFactor = bucketFactor;
		this.bucketFactorDiv2 = (int) Math.ceil((double) bucketFactor / 2);

		this.emptyRecord = emptyRecord;

		// Η ρίζα και ο δείκτης του πρώτου φύλλου αρχικά δείχνουν στον ίδιο
		// κόμβο.
		this.firstLeaf = new PrimaryLeaf(this.nextPageNumber++);
		this.root = this.firstLeaf;
	} // end method PrimaryBPlusTree

	/**
	 * Searches for a primary leaf using its key. When the primary leaf is found
	 * it is returned.
	 * 
	 * @param key
	 *            The key of the primary leaf-target.
	 * @return The desired <code>PrimaryLeaf</code>.
	 */
	private PrimaryLeaf search(final int key) {
		// Ξεκινώντας απ' τη ρίζα...
		Node currentNode = this.root;

		// διασχίζεται το δένδρο μέχρι να βρεθεί το φύλλο με το ζητούμενο
		// κλειδί.
		int index = 0;
		while (currentNode.getNodeType() == NodeType.INNER_NODE
				&& index <= this.bucketFactor) {
			InnerNode currentInnerNode = (InnerNode) currentNode;
			if (currentInnerNode.isLastKeyEntry(index)
					|| key < currentInnerNode.getKey(index)) {
				currentNode = currentInnerNode.getChild(index);
				index = 0;
			} // end if
			else {
				// Αν το ζητούμενο κλειδί έχει τιμή μεγαλύτερη ή ίση απ' αυτή
				// που εξετάζεται, τότε προχωρούμε στην επομένη.
				index++;
			} // end else
		}// end while
		return (PrimaryLeaf) currentNode;
	} // end method searchPrimaryIndex

	/**
	 * Inserts a new record to the appropriate position inside the Primary B+
	 * Tree.
	 * 
	 * @param newRecord
	 *            The record to be inserted.
	 * @return Information on the succesful insertion and on the update of the secondary indexes.
	 */
	public Object[] insert(final Record newRecord) {
		// Βρίσκουμε σε ποιο φύλλο αντιστοιχεί η νέα εγγραφή.
		PrimaryLeaf currentLeaf = this.search(newRecord.getPrimaryKey());

		// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
		Page currentPage = DiskHandler.loadPage(currentLeaf.getPageNumber(),
				this.bucketFactor, this.emptyRecord.clone());

		// Εκτελούμε την εισαγωγή στη σελίδα αυτή και παίρνουμε κάποια
		// αποτελέσματα σχετικά με την επιτυχία της εισαγωγής και τη θέση στη
		// σελίδα.
		Object[] insertionInfo = currentPage.insertRecord(newRecord);

		// Στα παραπάνω αποτελέσματα συμπληρώνουμε και σε ποια σελίδα έγινε η
		// εισαγωγή.
		insertionInfo[1] = currentLeaf.getPageNumber();

		// Ελέγχουμε εάν έχει προκύψει υπερχείλιση.
		if ((Boolean) insertionInfo[0]) {
			LinkedList<Record> recordsMoved = new LinkedList<Record>();
			LinkedList<Reference> oldReferenceList = new LinkedList<Reference>();
			LinkedList<Reference> newReferenceList = new LinkedList<Reference>();

			if (currentPage.isReplete()) {
				// Φτιάχνουμε ένα νέο φύλλο και μια νέα σελίδα (που γεμίζει με
				// τις μισές εγγραφές).
				PrimaryLeaf newLeaf = this.splitPrimaryLeaf(currentLeaf);
				Page newPage = this.splitPage(currentPage, currentLeaf,
						newLeaf, recordsMoved, oldReferenceList,
						newReferenceList);

				if ((Integer) insertionInfo[2] >= this.bucketFactorDiv2) {
					int insertionPos = (Integer) insertionInfo[2];

					// Υπολογίζεται η θέση της νέας εγγραφής στη νέα σελίδα.
					insertionPos = insertionPos - this.bucketFactorDiv2;

					// Πρέπει να αφαιρεθεί απ' τις λίστες, διότι δεν υπάρχει
					// ακόμη τέτοια αναφορά στους δευτερεύοντες καταλόγους. Θα
					// δημιουργηθεί και θα εισαχθεί σ' αυτούς μετά το τέλος της
					// διαδικασίας εισαγωγής.
					recordsMoved.remove(insertionPos);
					oldReferenceList.remove(insertionPos);
					newReferenceList.remove(insertionPos);

					insertionInfo[1] = newLeaf.getPageNumber();
					insertionInfo[2] = insertionPos;
				} // end if

				// Αναδομείται ο κατάλογος για να περιλαμβάνει και το νέο φύλλο.
				this.reconstructTree(currentLeaf, newLeaf, newPage);

				// Η νέα σελίδα γράφεται στον δίσκο.
				DiskHandler.writePage(newPage, newLeaf.getPageNumber());
			} // end if
			else {
				// Βρίσκουμε τις εγγραφές που έχουν μετατοπισθεί.
				for (int i = (Integer) insertionInfo[2] + 1; i < currentPage
						.getPageLength(); i++) {
					// Συλλογή στοιχείων που απαιτούνται για την ενημέρωση των
					// δευτερευόντων καταλόγων.
					recordsMoved.add(currentPage.getRecord(i));

					Reference oldReference = new Reference(-1, currentLeaf
							.getPageNumber(), i - 1);
					oldReferenceList.add(oldReference);

					Reference newReference = new Reference(-1, currentLeaf
							.getPageNumber(), i);
					newReferenceList.add(newReference);
				} // end for
			} // end else

			// Εάν κάποιες εγγραφές έχουν αλλάξει θέση, τότε θα πρέπει να
			// ενημερωθούν οι δευτερεύοντες κατάλογοι.
			if (recordsMoved.size() > 0) {
				Main.exe.updateSecondaryIndexes(recordsMoved, oldReferenceList,
						newReferenceList);
			} // end if
		} // end if

		// Η παλαιά σελίδα (ανανεωμένη πλέον) γράφεται στον δίσκο.
		DiskHandler.writePage(currentPage, currentLeaf.getPageNumber());

		return insertionInfo;
	} // end method insert

	/**
	 * Splits a replete page into two pages in order for the new record to be inserted.
	 * After the spliting of the first page in two, the first page contains <code>bucketFactorDiv2</code>
	 * elements and the second page the rest.
	 * Information is gathered regarding the necessary update of the secondary indexes.
	 * 
	 * @param currentPage
	 *            The current page that is replete.
	 * @param currentLeaf
	 *            The current leaf.
	 * @param newLeaf
	 *            A new leaf to host (<code>bucketFactorDiv2</code> + 1) records.
	 * @param recordsMoved
	 *            The records that were moved. We need them to update the
	 *            secondary indexes.
	 * @param oldStatusList
	 *            The old status of the list of records.
	 * @param newStatusList
	 *            The new status of the list of records.
	 * @return The new page.
	 */
	private Page splitPage(final Page currentPage,
			final PrimaryLeaf currentLeaf, final PrimaryLeaf newLeaf,
			final LinkedList<Record> recordsMoved,
			final LinkedList<Reference> oldStatusList,
			final LinkedList<Reference> newStatusList) {
		// Δημιουργία μιας νέας σελίδας και μεταφορά των μισών εγγραφών σ' αυτή.
		Page newPage = new Page(this.bucketFactor, this.emptyRecord);
		int i;
		for (i = this.bucketFactorDiv2; i < this.bucketFactor; i++) {
			// Συλλογή στοιχείων που απαιτούνται για την ενημέρωση των
			// δευτερευόντων καταλόγων.
			recordsMoved.add(currentPage.getRecord(this.bucketFactorDiv2));

			Reference oldReference = new Reference(-1, currentLeaf
					.getPageNumber(), i);
			oldStatusList.add(oldReference);

			// Αντιγραφή της εγγραφής στη νέα σελίδα.
			newPage.setRecordLast(currentPage.getRecord(this.bucketFactorDiv2)
					.clone());

			// Διαγραφή της εγγαφής της παλαιάς σελίδας.
			currentPage.deleteRecord(this.bucketFactorDiv2);

			// Συλλογή στοιχείων που απετούνται για την ενημέρωση των
			// δευτερευόντων καταλόγων.
			// Έχει προηγηθεί η εισαγωγή στη νέα σελίδα, άρα το getPageLength()
			// έχει αυξηθεί!
			Reference newReference = new Reference(-1, newLeaf.getPageNumber(),
					newPage.getPageLength() - 1);
			newStatusList.add(newReference);
		} // end for

		// Συλλογή στοιχείων που απαιτούνται για την ενημέρωση των
		// δευτερευόντων καταλόγων.
		recordsMoved.add(currentPage.getRecord(this.bucketFactorDiv2));

		Reference oldReference = new Reference(-1, currentLeaf.getPageNumber(),
				i);
		oldStatusList.add(oldReference);

		// Η τελευταία εγγραφή δεν αντιγράφεται αλλά αφαιρείται απ' τη μια
		// σελίδα και προστίθεται στην άλλη.
		// Με αυτό τον τρόπο εξασφαλίζεται ότι η σελίδα περιέχει πλήθος εγγραφών
		// ίσο με bucketFactor.
		newPage.setRecordLast(currentPage.removeRecord(this.bucketFactorDiv2));

		// Συλλογή στοιχείων που απαιτούνται για την ενημέρωση των
		// δευτερευόντων καταλόγων.
		// Έχει προηγηθεί η εισαγωγή στη νέα σελίδα, άρα το getPageLength()
		// έχει αυξηθεί!
		Reference newReference = new Reference(-1, newLeaf.getPageNumber(),
				newPage.getPageLength() - 1);
		newStatusList.add(newReference);

		return newPage;
	} // end method splitPage

	/**
	 * Splits a primary leaf to two and then the children's connections between
	 * them and their neighbours are being adjusted.
	 * 
	 * @param currentLeaf
	 *            The current primary leaf.
	 * @return The new primary leaf.
	 */
	private PrimaryLeaf splitPrimaryLeaf(final PrimaryLeaf currentLeaf) {
		// Δημιουργία ενός νέου φύλλου που δείχνει στην κατάλληλη σελίδα.
		PrimaryLeaf newLeaf = new PrimaryLeaf(this.nextPageNumber++);

		// Ενημέρωση των δεικτών των φύλλων προς τα γειτονικά τους.
		PrimaryLeaf thirdLeaf = currentLeaf.getRightLeaf();

		newLeaf.setRightLeaf(thirdLeaf);
		currentLeaf.setRightLeaf(newLeaf);

		if (thirdLeaf != null) {
			thirdLeaf.setLeftLeaf(newLeaf);
		} // end if
		newLeaf.setLeftLeaf(currentLeaf);

		return newLeaf;
	} // end method splitPrimaryLeaf

	/**
	 * Reconstructs the tree in order to adjust it to changes that may have 
	 * happened (after a page and a primary leaf is split).
	 * 
	 * @param currentLeaf
	 *            The current leaf.
	 * @param newLeaf
	 *            The new leaf.
	 * @param newPage
	 *            The new page.
	 */
	private void reconstructTree(final PrimaryLeaf currentLeaf,
			final PrimaryLeaf newLeaf, final Page newPage) {
		// Εξέταση έαν υπάρχει γονέας για τον τρέχοντα κόμβο.
		if (currentLeaf.getParent() == null) {
			// Δημιουργία γονέα (τίθεται αυτόματα ρίζα).
			this.createNewParent(currentLeaf, newLeaf, newPage.getRecord(0)
					.getPrimaryKey());
		} // end if
		else {
			// Ενημέρωση γονέα και παιδιών.
			InnerNode currentNode = currentLeaf.getParent();

			newLeaf.setParent(currentNode);
			Node newNode = newLeaf;

			// Αναδόμηση του καταλόγου.
			this.reconstructInnerNodes(newPage.getRecord(0).getPrimaryKey(),
					currentNode, newNode);
		} // end else
	} // end method reconstructTree

	/**
	 * When the tree is being reconstructed some nodes may not have a parent.
	 * This method constructs a new parent and connects it to the orphan
	 * node(s).
	 * 
	 * @param firstChild
	 *            The first child.
	 * @param secondChild The second child.
	 * @param key The key of the Nodes
	 */
	private void createNewParent(final Node firstChild, final Node secondChild,
			final int key) {
		// Ο νέος γονέας γίνεται ρίζα.
		InnerNode parent = new InnerNode(this.bucketFactor);
		this.root = parent;

		// Ενημέρωση δεικτών.
		firstChild.setParent(parent);
		secondChild.setParent(parent);

		// Εισαγωγή κλειδιού - παιδιών στον νέο γονέα.
		parent.addFirst(key, firstChild);
		parent.addLastChild(secondChild);
	} // end method createNewParent

	/**
	 * Reconstructs inner nodes after new nodes have been created (possibly from
	 * a split procedure). Checks if a repletion takes place too.
	 * 
	 * @param key
	 *            The current node's key.
	 * @param currentNode
	 *            The current node.
	 * @param newNode
	 *            The new node.
	 */
	private void reconstructInnerNodes(int key, InnerNode currentNode,
			Node newNode) {
		boolean repeat = true;
		while (repeat) {
			// Εισαγωγή κλειδιού στον κόμβο.
			currentNode.insertKey(key, newNode);

			// Έλεγχος υπερχείλισης.
			if (currentNode.isReplete()) {
				// Αφαιρείται το μεσαίο κλειδί...
				key = currentNode.removeKey(this.bucketFactorDiv2);

				// και γίνεται διάσπαση του κόμβου.
				newNode = this.splitInnerNode(currentNode);

				// Έλεγχος γαι την ύπαρξη γονέα.
				if (currentNode.getParent() == null) {
					// Δημιουργία γονέα.
					createNewParent(currentNode, newNode, key);

					// Τερματισμός της αναδόμησης.
					repeat = false;
				} // end if
				else {
					// Ο έλεγχος περνά στον γονέα.
					currentNode = currentNode.getParent();

					// Ενημέρωση δεικτών.
					newNode.setParent(currentNode);
				} // end else
			} // end if
			else {
				// Τερματισμός της αναδόμησης.
				repeat = false;
			} // end else
		} // end while
	} // end method reconstructInnerNodes

	/**
	 * Splits an inner node to two and places half the children to the first and
	 * the other to the second. The parent(s) are being updated too.
	 * 
	 * @param currentNode
	 *            The node to be splited.
	 * @return The new InnerNode.
	 */
	private InnerNode splitInnerNode(final InnerNode currentNode) {
		// Έχει προηγηθεί η αφαίρεση του μεσαίου παιδιού του κόμβου!

		Node child;
		InnerNode newNode = new InnerNode(this.bucketFactor);

		// Μεταφορά των μισών στοιχείων σε έναν νέο κόμβο.
		for (int i = this.bucketFactorDiv2; i < this.bucketFactor; i++) {
			child = currentNode.removeChild(this.bucketFactorDiv2 + 1);

			// Αφού ο κόμβος αλλάζει γονέα πρέπει να ενημερωθεί και το
			// αντίστοιχο πεδίο του.
			child.setParent(newNode);

			// Εισαγωγή του κλειδιού στον νέο κόμβο.
			newNode
					.addLast(currentNode.removeKey(this.bucketFactorDiv2),
							child);
		} // end for

		// Για τη μεταφορά ν κλειδιών πρέπει να μεταφερθούν ν + 1 παιδιά.
		// Έτσι εδώ μεταφέρουμε ένα παιδί αλλά όχι ένα κλειδί.
		child = currentNode.removeChild(this.bucketFactorDiv2 + 1);
		child.setParent(newNode);
		newNode.addLastChild(child);

		return newNode;
	} // end method splitInnerNode

	/**
	 * Deletes a record (With key equal to the <code>PrimaryKey</code>)
	 * and updates the information of the primary B+ Tree, of the references which
	 * were changed and of the hard disk as well.
	 * 
	 * @param primaryKey
	 *            The desired key.
	 * @return A <code>Result [5]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the deletion.
	 *         <li>A <code>LinkedList</code> object with the deleted records and their
	 *         position.
	 *         <li>Three <code>LinkedList</code> objects which have
	 *         information to update the references of the records which were
	 *         moved after the deletion.
	 *         </ul>
	 */
	public Object[] delete(final int primaryKey) {
		// Για διαγραφή ενός πρωτεύοντος κλειδιού.

		Object[] result = new Object[5];
		LinkedList<Object[]> deleted = new LinkedList<Object[]>();

		// Αναζήτηση για το φύλλο που αναφέρεται σε αυτό το κλειδί.
		PrimaryLeaf currentLeaf = this.search(primaryKey);

		// Φόρτωμα της αντίστοιχης σελίδας.
		Page page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
				this.bucketFactor, this.emptyRecord.clone());

		// Σάρωση των εγγραφών μέχρι να βρεθεί αυτή που θα διαγραφεί.
		int i;
		for (i = 0; i < page.getPageLength(); i++) {
			if (page.getRecord(i).getPrimaryKey() == primaryKey) {
				Object[] recordStatus = new Object[2];

				// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
				recordStatus[0] = page.getRecord(i);

				// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
				// πραγματοποιήθηκε η διαγραφή.
				Reference newReference = new Reference(-1, currentLeaf
						.getPageNumber(), i);
				recordStatus[1] = newReference;

				// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων που
				// θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων
				// καταλόγων.
				deleted.add(recordStatus);

				// Διαγράφουμε την εγγραφή απ' τη σελίδα.
				page.deleteRecord(i);
				break;
			} // end if
		} // end for

		// Η σελίδα (ανανεωμένη πλέον) γράφεται στον δίσκο.
		DiskHandler.writePage(page, currentLeaf.getPageNumber());

		// Απ' το αντίγραφο της σελίδας που παραμένει στη μνήμη συλλέγουμε
		// στοιχεία για τις εγγραφές που μετακινήθηκαν μετά την διαγραφή.

		LinkedList<Record> recordsMoved = new LinkedList<Record>();
		LinkedList<Reference> oldReferenceList = new LinkedList<Reference>();
		LinkedList<Reference> newReferenceList = new LinkedList<Reference>();

		// Προσοχή: ξεκινούμε απ' τη θέση i, διότι εκεί πλέον βρίσκεται η
		// εγγραφή που βρισκόταν στη θέση i + 1!
		for (int j = i; j < page.getPageLength(); j++) {
			// Συλλογή στοιχείων που απαιτούνται για την ενημέρωση των
			// δευτερευόντων καταλόγων.
			recordsMoved.add(page.getRecord(j));

			Reference oldReference = new Reference(-1, currentLeaf
					.getPageNumber(), j + 1);
			oldReferenceList.add(oldReference);

			Reference newReference = new Reference(-1, currentLeaf
					.getPageNumber(), j);
			newReferenceList.add(newReference);
		} // end for

		// Η μέθοδος επιστρέφει μια πεντάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής, μια λίστα με
		// τις εγγραφές και τις θέσεις των διεγραμένων εγγραφών και τρεις άλλες
		// λίστες που κρατούν στοιχεία για την ενημέρωση των αναφορών των
		// εγγραφών που μετακινήθηκαν μετά την διαγραφή.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;
		result[2] = recordsMoved;
		result[3] = oldReferenceList;
		result[4] = newReferenceList;

		return result;
	} // end method delete

	/**
	 * Same as the <code>delete</code> method, only here we delete all the
	 * records with key greater or equal to the <code>PrimaryKey</code>. We
	 * also do not update references beacause of the way that this kind of deletion
	 * takes place. It does not move any records inside the page.
	 * 
	 * @param primaryKey
	 *            The desired key.
	 * @return A <code>Result [5]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         deletion
	 *         <li>A <code>LinkedList</code> object with the deleted records and their
	 *         positions.
	 *         <li> Three <code>LinkedList</code> objects which have
	 *         information to update the references of the records which were
	 *         moved after the deletion (they are not used in this method).
	 *         </ul>
	 * 
	 */
	public Object[] deleteAllGreaterOrEqual(final int primaryKey) {
		// Για διαγραφή όλων των πρωτευόντων κλειδιών με τιμή μεγαλύτερη ή ίση
		// με αυτή που δόθηκε.

		Object[] result = new Object[5];
		LinkedList<Object[]> deleted = new LinkedList<Object[]>();

		// Αναζήτηση για το φύλλο που αναφέρεται σε αυτό το κλειδί.
		PrimaryLeaf currentLeaf = this.search(primaryKey);

		// Φόρτωμα της αντίστοιχης σελίδας.
		Page page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
				this.bucketFactor, this.emptyRecord.clone());

		// Επειδή τα πρωτεύοντα κλειδιά είναι ταξινομημένα, βρίσκουμε το πρώτο
		// μεγαλύτερο ή ίσο...
		int index = 0;
		while (index < page.getPageLength()
				&& page.getRecord(index).getPrimaryKey() < primaryKey) {
			// Εάν η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index++;
		} // end while

		// και στη συνέχεια διαγράφουμε αυτό και όσα βρίσκονται δεξιά απ' αυτό.
		int i;
		for (i = page.getPageLength() - 1; i > index - 1; i--) {
			Object[] recordStatus = new Object[2];

			// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
			recordStatus[0] = page.getRecord(i);

			// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
			// πραγματοποιήθηκε η διαγραφή.
			Reference newReference = new Reference(-1, currentLeaf
					.getPageNumber(), i);
			recordStatus[1] = newReference;

			// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων που
			// θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων
			// καταλόγων.
			deleted.add(recordStatus);

			// Διαγράφουμε την εγγραφή απ' τη σελίδα.
			page.deleteRecord(i);
		} // end for

		// Η σελίδα (ανανεωμένη πλέον) γράφεται στον δίσκο.
		DiskHandler.writePage(page, currentLeaf.getPageNumber());

		// Μετά διαγράφουμε όλες τις εγγραφές σε όλες τις σελίδες που βρίσκονται
		// δεξιά της προηγουμένης - για αυτά δεν χρείαζεται να γίνει ενημέρωση
		// των αντίσοιχων αναφορών στα πεδία της σελίδας και της θέσης της
		// εγγραφής, διότι οι αναφορές αυτές απλά θα διαγρφούν.
		currentLeaf = currentLeaf.getRightLeaf();

		while (currentLeaf != null) {
			// Φόρτωμα της σελίδας.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord.clone());

			// Διαγραφή των εγγραφών από το τέλος προς την αρχή για να
			// αποφευχθούν οι παρενέργειες της αναταξινόμησης κατά τη διαγραφή.
			for (int k = page.getPageLength() - 1; k > -1; k--) {
				Object[] recordStatus = new Object[2];

				// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
				recordStatus[0] = page.getRecord(k);

				// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
				// πραγματοποιήθηκε η διαγραφή.
				Reference newReference = new Reference(-1, currentLeaf
						.getPageNumber(), k);
				recordStatus[1] = newReference;

				// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων που
				// θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων
				// καταλόγων.
				deleted.add(recordStatus);

				// Διαγράφουμε την εγγραφή απ' τη σελίδα.
				page.deleteRecord(k);
			} // end for

			// Η σελίδα (ανανεωμένη πλέον) γράφεται στον δίσκο.
			DiskHandler.writePage(page, currentLeaf.getPageNumber());

			// Μετακινούμαστε στη δεξιά σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής και μια λίστα
		// με τις εγγραφές και τις θέσεις των διεγραμένων εγγραφών.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;
		result[2] = new LinkedList<Record>();
		result[3] = new LinkedList<Reference>();
		result[4] = new LinkedList<Reference>();

		// ΣΗΜΕΙΩΣΗ: εδώ δεν χρειάζεται να γίνει ενημέρωση των αναφορών των
		// δευτερευόντων καταλόγων, διότι οι διαγραφές που πραγματοποιούνται δεν
		// προκαλούν μετακινήσεις εγγραφών μέσα στη σελίδα. Οι παραπάνω
		// αναθέσεις διευκολήνουν στους ελέγχους.

		return result;
	} // end method deleteAllGreaterOrEqual

	/**
	 * Same as the <code>delete</code> method except here it deletes all the records
	 * with key of lesser or equal value to the <code>PrimaryKey</code>. Then updates
	 * the information of the primary B+ Tree, of the references which were changed
	 * and of the hard disk as well.
	 * 
	 * @param primaryKey
	 *            The desired key.
	 * @return A <code>Result [5]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         deletion.
	 *         <li>A <code>LinkedList</code> object with the deleted records and their
	 *         positions.
	 *         <li> Three <code>LinkedList</code> objects which have
	 *         information to update the references of the records which were
	 *         moved after the deletion.
	 *         </ul>
	 */
	public Object[] deleteAllLessOrEqual(final int primaryKey) {
		// Για διαγραφή όλων των πρωτευόντων κλειδιών με τιμή μικρότερη ή ίση
		// με αυτή που δόθηκε.

		Object[] result = new Object[5];
		LinkedList<Object[]> deleted = new LinkedList<Object[]>();

		// Αναζήτηση για το φύλλο που αναφέρεται σε αυτό το κλειδί.
		PrimaryLeaf currentLeaf = this.search(primaryKey);

		// Φόρτωμα της αντίστοιχης σελίδας.
		Page page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
				this.bucketFactor, this.emptyRecord.clone());

		// Επειδή τα πρωτεύοντα κλειδιά είναι ταξινομημένα, βρίσκουμε το πρώτο
		// μικρότερο ή ίσο...
		int index = page.getPageLength() - 1;
		while (index > -1 && page.getRecord(index).getPrimaryKey() > primaryKey) {
			// Εάν η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index--;
		} // end while

		// και στη συνέχεια διαγράφουμε αυτό και όσα βρίσκονται αριστερά απ'
		// αυτό.
		int i;
		for (i = index; i > -1; i--) {
			Object[] recordStatus = new Object[2];
			// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
			recordStatus[0] = page.getRecord(i);

			// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
			// πραγματοποιήθηκε η διαγραφή.
			Reference newReference = new Reference(-1, currentLeaf
					.getPageNumber(), i);
			recordStatus[1] = newReference;

			// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων που
			// θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων καταλόγων.
			deleted.add(recordStatus);

			// Διαγράφουμε την εγγραφή απ' τη σελίδα.
			page.deleteRecord(i);
		} // end for

		// Η σελίδα (ανανεωμένη πλέον) γράφεται στον δίσκο.
		DiskHandler.writePage(page, currentLeaf.getPageNumber());

		// Απ' το αντίγραφο της σελίδας που παραμένει στη μνήμη συλλέγουμε
		// στοιχεία για τις εγγραφές που μετακινήθηκαν μετά την διαγραφή.

		LinkedList<Record> recordsMoved = new LinkedList<Record>();
		LinkedList<Reference> oldReferenceList = new LinkedList<Reference>();
		LinkedList<Reference> newReferenceList = new LinkedList<Reference>();

		// Προσοχή: ξεκινούμε απ' τη θέση 0, διότι εκεί πλέον βρίσκεται η
		// πρώτη απ' τις εγγραφές που δεν διαγράφηκε!
		for (int j = 0; j < page.getPageLength(); j++) {
			// Συλλογή στοιχείων που απαιτούνται για την ενημέρωση των
			// δευτερευόντων καταλόγων.
			recordsMoved.add(page.getRecord(j));

			Reference oldReference = new Reference(-1, currentLeaf
					.getPageNumber(), j + 1 + index);
			oldReferenceList.add(oldReference);

			Reference newReference = new Reference(-1, currentLeaf
					.getPageNumber(), j);
			newReferenceList.add(newReference);
		} // end for

		// Μετά διαγράφουμε όλες τις εγγραφές σε όλες τις σελίδες που βρίσκονται
		// αριστερά της προηγουμένης.
		currentLeaf = currentLeaf.getLeftLeaf();

		while (currentLeaf != null) {
			// Φόρτωμα της σελίδας.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord.clone());

			// Διαγραφή των εγγραφών από το τέλος προς την αρχή για να
			// αποφευχθούν οι παρενέργειες της αναταξινόμησης κατά τη διαγραφή.
			for (int k = page.getPageLength() - 1; k > -1; k--) {
				Object[] recordStatus = new Object[2];
				// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
				recordStatus[0] = page.getRecord(k);

				// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
				// πραγματοποιήθηκε η διαγραφή.
				Reference newReference = new Reference(-1, currentLeaf
						.getPageNumber(), k);
				recordStatus[1] = newReference;

				// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων που
				// θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων
				// καταλόγων.
				deleted.add(recordStatus);

				// Διαγράφουμε την εγγραφή απ' τη σελίδα.
				page.deleteRecord(k);
			} // end for

			// Η σελίδα (ανανεωμένη πλέον) γράφεται στον δίσκο.
			DiskHandler.writePage(page, currentLeaf.getPageNumber());

			// Μετακινούμαστε στην αριστερή σελίδα.
			currentLeaf = currentLeaf.getLeftLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια πεντάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής, μια λίστα με
		// τις εγγραφές και τις θέσεις των διεγραμένων εγγραφών και τρεις άλλες
		// λίστες που κρατούν στοιχεία για την ενημέρωση των αναφορών των
		// εγγραφών που μετακινήθηκαν μετά την διαγραφή.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;
		result[2] = recordsMoved;
		result[3] = oldReferenceList;
		result[4] = newReferenceList;

		return result;
	} // end method deleteAllLessOrEqual

	/**
	 * It is used to delete records after a deletion made in a secondary index.
	 * It then collects information about updating the references of the secondary indexes.
	 * 
	 * @param referenceList
	 *            The list with the references that were deleted from a secondary
	 *            index
	 * @return A <code>Result [5]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         deletion.
	 *         <li>A <code>LinkedList</code> object with the deleted records and their
	 *         positions.
	 *         <li> Three <code>LinkedList</code> objects which have
	 *         information to update the references of the records which were
	 *         moved after the deletion.
	 *         </ul>
	 */
	@SuppressWarnings("unchecked")
	public Object[] delete(final LinkedList<Reference> referenceList) {
		// Για διαγραφή πολλών εγγραφών - χρησιμοποιείται μετά από διαγραφή σε
		// δευτερεύοντα κατάλογο.

		Object[] result = new Object[5];
		LinkedList<Object[]> deleted = new LinkedList<Object[]>();
		LinkedList<Record> recordsMoved = new LinkedList<Record>();
		LinkedList<Reference> oldReferenceList = new LinkedList<Reference>();
		LinkedList<Reference> newReferenceList = new LinkedList<Reference>();

		// Ταξινόμηση των αναφορών με βάση τους αριθμούς σελίδων τους και τη
		// θέση μέσα στη σελίδα.
		Collections.sort(referenceList, new Comparator<Reference>() {
			public int compare(Reference firstReference,
					Reference secondReference) {
				if (firstReference.getPageNumber() < secondReference
						.getPageNumber())
					return -1;
				else if (firstReference.getPageNumber() > secondReference
						.getPageNumber())
					return 1;
				else if (firstReference.getOffset() < secondReference
						.getOffset())
					return -1;
				else if (firstReference.getOffset() > secondReference
						.getOffset())
					return 1;
				else
					return 0;
			}
		});

		// Παίρνουμε όλες τις αναφορές μια - μια και βρίσκουμε την εγγραφή που
		// αντιστοιχεί σε κάθε μια απ' αυτές.
		int pageNumber = referenceList.get(0).getPageNumber();
		int offsetOfFirst = referenceList.get(0).getOffset();

		// Φόρτωμα της αντίστοιχης σελίδας.
		Page page = DiskHandler.loadPage(pageNumber, this.bucketFactor,
				this.emptyRecord);

		Reference reference;
		int deletedInThisPage = 0;
		while (referenceList.size() > 0) {
			reference = referenceList.remove();

			if (pageNumber != reference.getPageNumber()) {
				// Η προηγούμενη σελίδα (ανανεωμένη πλέον) γράφεται στον δίσκο.
				DiskHandler.writePage(page, pageNumber);

				// Απ' το αντίγραφο της σελίδας που παραμένει στη μνήμη
				// συλλέγουμε στοιχεία για τις εγγραφές που μετακινήθηκαν μετά
				// την διαγραφή.

				// Προσοχή: ξεκινούμε απ' τη θέση offsetOfFirst, διότι εκεί
				// πλέον βρίσκεται η πρώτη απ' τις εγγραφές αυτής της σελίδας
				// που δεν διαγράφηκε!
				for (int j = offsetOfFirst; j < page.getPageLength(); j++) {
					// Συλλογή στοιχείων που απαιτούνται για την ενημέρωση των
					// δευτερευόντων καταλόγων.
					recordsMoved.add(page.getRecord(j));

					Reference oldReference = new Reference(-1, pageNumber, j
							+ deletedInThisPage);
					oldReferenceList.add(oldReference);

					Reference newReference = new Reference(-1, pageNumber, j);
					newReferenceList.add(newReference);
				} // end for

				// Φορτώνουμε την κατάλληλη σελίδα.
				page = DiskHandler.loadPage(reference.getPageNumber(),
						this.bucketFactor, this.emptyRecord);

				pageNumber = reference.getPageNumber();
				offsetOfFirst = reference.getOffset();
				deletedInThisPage = 0;
			} // end if

			Object[] recordStatus = new Object[2];

			// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
			recordStatus[0] = page.getRecord(reference.getOffset()
					- deletedInThisPage);

			// Αποθηκευουμε την (παλαιά - πριν τις διαγραφές) αναφορά της
			// εγγραφής.
			recordStatus[1] = reference;

			// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων που θα
			// χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων καταλόγων.
			deleted.add(recordStatus);

			// Διαγράφουμε την εγγραφή απ' τη σελίδα. -
			page.deleteRecord(reference.getOffset() - deletedInThisPage);

			// Αυξάνεται η μεταβλητή που δείχνει πόσες εγγραφές <<σκοτώθηκαν>>
			// σ' αυτή τη σελίδα. Ο λόγος που χρησιμοποιείται είναι ότι μια
			// διεγραμένη εγγραφή μετατοπίζεται στο τέλος για να διατηρηθεί η
			// ταξινόμηση. Αυτό έχει ως αποτέλεσμα να
			deletedInThisPage++;
		} // end while

		// Η προηγούμενη σελίδα (ανανεωμένη πλέον) γράφεται στον δίσκο.
		DiskHandler.writePage(page, pageNumber);

		// Η μέθοδος επιστρέφει μια πεντάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής, μια λίστα με
		// τις εγγραφές και τις θέσεις των διεγραμένων εγγραφών και τρεις άλλες
		// λίστες που κρατούν στοιχεία για την ενημέρωση των αναφορών των
		// εγγραφών που μετακινήθηκαν μετά την διαγραφή.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;
		result[2] = recordsMoved;
		result[3] = oldReferenceList;
		result[4] = newReferenceList;

		return result;
	} // end method delete

	/**
	 * Deletes records using the <code>secondaryKey</code>. It
	 * then collects information about updating all references needed. This method is necessarily
	 * sequential.
	 * 
	 * @param secondaryKey
	 *            The desired secondary key.
	 * @param keyIndex
	 *            The desired key's index.
	 * @return A <code>Result [5]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         deletion.
	 *         <li>A <code>LinkedList</code> object with the records and
	 *         positions of the deleted records.
	 *         <li> Three <code>LinkedList</code> objects which have
	 *         information to update the references of the records which were
	 *         moved after the deletion.
	 *         </ul>
	 */
	public Object[] delete(final int secondaryKey, final int keyIndex) {
		// Για διαγραφή εγγραφών με βάση ένα δευτερεύον κλειδί - αναγκαστικά
		// σειριακή διαδικασία.

		Object[] result = new Object[5];
		LinkedList<Object[]> deleted = new LinkedList<Object[]>();
		LinkedList<Record> recordsMoved = new LinkedList<Record>();
		LinkedList<Reference> oldReferenceList = new LinkedList<Reference>();
		LinkedList<Reference> newReferenceList = new LinkedList<Reference>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		Page page;
		int movedInPreviousPages;
		int deletedInThisPage;
		while (currentLeaf != null) {
			// Ενημερώνεται το πεδίο που κρατά τον αριθμό των εγγραφών που
			// μετακινήθηκαν σε προηγούμενα φύλλα.
			movedInPreviousPages = recordsMoved.size();

			// Αρχικά δεν έχει γίνει κάποια διαγραφή σ' αυτή τη σελίδα.
			deletedInThisPage = 0;

			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Πριν αρχίσουν οι διαγραφές δημιουργούμε αναφορές για όλες τις
			// εγγραφές, όμοιες με αυτές που υπάρχουν στους δευτερεύοντες
			// καταλόγους.
			for (int j = 0; j < page.getPageLength(); j++) {
				recordsMoved.add(page.getRecord(j));

				Reference oldReference = new Reference(-1, currentLeaf
						.getPageNumber(), j);
				oldReferenceList.add(oldReference);

				// Αρχικά είναι όμοια με την oldReference, αλλά εάν προκύψει
				// διαγραφή στο φύλλο θα τροποποιηθεί.
				Reference newReference = new Reference(-1, currentLeaf
						.getPageNumber(), j);
				newReferenceList.add(newReference);
			} // end for

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if ((Integer) page.getRecord(index).getKey(keyIndex) == secondaryKey) {
					Object[] recordStatus = new Object[2];

					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					recordStatus[0] = page.getRecord(index);

					// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
					// πραγματοποιήθηκε η διαγραφή.
					Reference newReference = new Reference(-1, currentLeaf
							.getPageNumber(), index + deletedInThisPage);
					recordStatus[1] = newReference;

					// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων
					// που θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων
					// καταλόγων.
					deleted.add(recordStatus);

					// Διαγράφουμε την εγγραφή απ' τη σελίδα.
					page.deleteRecord(index);

					// Ενημερώνεται το πεδίο που κρατά τον αριθμό των εγγραφών
					// που διαγράφησαν σ' αυτή τη σελίδα.
					deletedInThisPage++;

					// Η αναφορά αφαιρείται απ' αυτές τις λίστες, αφού υπάρχει
					// στη λίστα των διεγραμένων.
					recordsMoved.remove(movedInPreviousPages + index);
					oldReferenceList.remove(movedInPreviousPages + index);
					newReferenceList.remove(movedInPreviousPages + index);

					// Ενημέρωση της λίστας με τη νέα αναφορά.
					for (int i = movedInPreviousPages + index; i < newReferenceList
							.size(); i++) {
						newReferenceList.get(i).setOffset(
								newReferenceList.get(i).getOffset() - 1);
					} // end for

					// Οι διαγραφές δεν σταματούν, διότι μπορεί να υπάρχουν και
					// άλλες εγγραφές με το ίδιο δευτερεύον κλειδί.
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Η ανανεωμένη πλέον σελίδα γράφεται στον δίσκο.
			DiskHandler.writePage(page, currentLeaf.getPageNumber());

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια πεντάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής, μια λίστα με
		// τις εγγραφές και τις θέσεις των διεγραμένων εγγραφών και τρεις άλλες
		// λίστες που κρατούν στοιχεία για την ενημέρωση των αναφορών των
		// εγγραφών που μετακινήθηκαν μετά την διαγραφή.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;
		result[2] = recordsMoved;
		result[3] = oldReferenceList;
		result[4] = newReferenceList;

		return result;
	} // end method delete

	/**
	 * Same as the <code>delete</code> method, only here it deletes all the records
	 * with key greater to the secondary key given to the parameter. Then
	 * updates the information to the primary B+ Tree, the references which were
	 * changed and the hard disk as well. This method is necessarily sequential.
	 * 
	 * @param secondaryKey
	 *            the desired secondary key
	 * @param keyIndex
	 *            the desired key index
	 * @return A <code>Result [5]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         deletion.
	 *         <li>A <code>LinkedList</code> object with the records and
	 *         positions of the deleted records.
	 *         <li> Three <code>LinkedList</code> objects which have
	 *         information to update the references of the records which were
	 *         moved after the deletion.
	 *         </ul>
	 */
	public Object[] deleteAllGreater(final int secondaryKey, final int keyIndex) {
		// Για σειριακή διαγραφή όλων των εγγραφών που έχουν τιμή μεγαλύτερη απ'
		// το διδόμενο δευτερεύον κλειδί - αναγκαστικά σειριακή διαδικασία.

		Object[] result = new Object[5];
		LinkedList<Object[]> deleted = new LinkedList<Object[]>();
		LinkedList<Record> recordsMoved = new LinkedList<Record>();
		LinkedList<Reference> oldReferenceList = new LinkedList<Reference>();
		LinkedList<Reference> newReferenceList = new LinkedList<Reference>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		Page page;
		int movedInPreviousPages;
		int deletedInThisPage;
		while (currentLeaf != null) {
			// Ενημερώνεται το πεδίο που κρατά τον αριθμό των εγγραφών που
			// μετακινήθηκαν σε προηγούμενα φύλλα.
			movedInPreviousPages = recordsMoved.size();

			// Αρχικά δεν έχει γίνει κάποια διαγραφή σ' αυτή τη σελίδα.
			deletedInThisPage = 0;

			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Πριν αρχίσουν οι διαγραφές δημιουργούμε αναφορές για όλες τις
			// εγγραφές, όμοιες με αυτές που υπάρχουν στους δευτερεύοντες
			// καταλόγους.
			for (int j = 0; j < page.getPageLength(); j++) {
				recordsMoved.add(page.getRecord(j));

				Reference oldReference = new Reference(-1, currentLeaf
						.getPageNumber(), j);
				oldReferenceList.add(oldReference);

				// Αρχικά είναι όμοια με την oldReference, αλλά εάν προκύψει
				// διαγραφή στο φύλλο θα τροποποιηθεί.
				Reference newReference = new Reference(-1, currentLeaf
						.getPageNumber(), j);
				newReferenceList.add(newReference);
			} // end for

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if ((Integer) page.getRecord(index).getKey(keyIndex) > secondaryKey) {
					Object[] recordStatus = new Object[2];

					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					recordStatus[0] = page.getRecord(index);

					// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
					// πραγματοποιήθηκε η διαγραφή.
					Reference newReference = new Reference(-1, currentLeaf
							.getPageNumber(), index + deletedInThisPage);
					recordStatus[1] = newReference;

					// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων
					// που θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων
					// καταλόγων.
					deleted.add(recordStatus);

					// Διαγράφουμε την εγγραφή απ' τη σελίδα.
					page.deleteRecord(index);

					// Ενημερώνεται το πεδίο που κρατά τον αριθμό των εγγραφών
					// που διαγράφησαν σ' αυτή τη σελίδα.
					deletedInThisPage++;

					// Η αναφορά αφαιρείται απ' αυτές τις λίστες, αφού υπάρχει
					// στη λίστα των διεγραμένων.
					recordsMoved.remove(movedInPreviousPages + index);
					oldReferenceList.remove(movedInPreviousPages + index);
					newReferenceList.remove(movedInPreviousPages + index);

					// Ενημέρωση της λίστας με τη νέα αναφορά.
					for (int i = movedInPreviousPages + index; i < newReferenceList
							.size(); i++) {
						newReferenceList.get(i).setOffset(
								newReferenceList.get(i).getOffset() - 1);
					} // end for

					// Οι διαγραφές δεν σταματούν, διότι μπορεί να υπάρχουν και
					// άλλες εγγραφές με το ίδιο δευτερεύον κλειδί.
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Η ανανεωμένη πλέον σελίδα γράφεται στον δίσκο.
			DiskHandler.writePage(page, currentLeaf.getPageNumber());

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια πεντάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής, μια λίστα με
		// τις εγγραφές και τις θέσεις των διεγραμένων εγγραφών και τρεις άλλες
		// λίστες που κρατούν στοιχεία για την ενημέρωση των αναφορών των
		// εγγραφών που μετακινήθηκαν μετά την διαγραφή.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;
		result[2] = recordsMoved;
		result[3] = oldReferenceList;
		result[4] = newReferenceList;

		return result;
	} // end method deleteAllGreater

	/**
	 * Same as the <code>delete</code> method, only here it deletes all the records
	 * with key lesser to the secondary key given to the parameter. Then updates
	 * the information to the primary B+ Tree, the references which were changed
	 * and the hard disk as well. This method is necessarily sequential.
	 * 
	 * @param secondaryKey
	 *            The desired secondary key.
	 * @param keyIndex
	 *            The desired key index.
	 * @return a <code>Result [5]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         deletion.
	 *         <li>A <code>LinkedList</code> object with the records and
	 *         positions of the deleted records.
	 *         <li> Three <code>LinkedList</code> objects which have
	 *         information to update the references of the records which were
	 *         moved after the deletion.
	 *         </ul>
	 */
	public Object[] deleteAllLess(final int secondaryKey, final int keyIndex) {
		// Για σειριακή διαγραφή όλων των εγγραφών που έχουν τιμή μικρότερη απ'
		// το διδόμενο δευτερεύον κλειδί - αναγκαστικά σειριακή διαδικασία.

		Object[] result = new Object[5];
		LinkedList<Object[]> deleted = new LinkedList<Object[]>();
		LinkedList<Record> recordsMoved = new LinkedList<Record>();
		LinkedList<Reference> oldReferenceList = new LinkedList<Reference>();
		LinkedList<Reference> newReferenceList = new LinkedList<Reference>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		Page page;
		int movedInPreviousPages;
		int deletedInThisPage;
		while (currentLeaf != null) {
			// Ενημερώνεται το πεδίο που κρατά τον αριθμό των εγγραφών που
			// μετακινήθηκαν σε προηγούμενα φύλλα.
			movedInPreviousPages = recordsMoved.size();

			// Αρχικά δεν έχει γίνει κάποια διαγραφή σ' αυτή τη σελίδα.
			deletedInThisPage = 0;

			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Πριν αρχίσουν οι διαγραφές δημιουργούμε αναφορές για όλες τις
			// εγγραφές, όμοιες με αυτές που υπάρχουν στους δευτερεύοντες
			// καταλόγους.
			for (int j = 0; j < page.getPageLength(); j++) {
				recordsMoved.add(page.getRecord(j));

				Reference oldReference = new Reference(-1, currentLeaf
						.getPageNumber(), j);
				oldReferenceList.add(oldReference);

				// Αρχικά είναι όμοια με την oldReference, αλλά εάν προκύψει
				// διαγραφή στο φύλλο θα τροποποιηθεί.
				Reference newReference = new Reference(-1, currentLeaf
						.getPageNumber(), j);
				newReferenceList.add(newReference);
			} // end for

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if ((Integer) page.getRecord(index).getKey(keyIndex) < secondaryKey) {
					Object[] recordStatus = new Object[2];

					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					recordStatus[0] = page.getRecord(index);

					// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
					// πραγματοποιήθηκε η διαγραφή.
					Reference newReference = new Reference(-1, currentLeaf
							.getPageNumber(), index + deletedInThisPage);
					recordStatus[1] = newReference;

					// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων
					// που θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων
					// καταλόγων.
					deleted.add(recordStatus);

					// Διαγράφουμε την εγγραφή απ' τη σελίδα.
					page.deleteRecord(index);

					// Ενημερώνεται το πεδίο που κρατά τον αριθμό των εγγραφών
					// που διαγράφησαν σ' αυτή τη σελίδα.
					deletedInThisPage++;

					// Η αναφορά αφαιρείται απ' αυτές τις λίστες, αφού υπάρχει
					// στη λίστα των διεγραμένων.
					recordsMoved.remove(movedInPreviousPages + index);
					oldReferenceList.remove(movedInPreviousPages + index);
					newReferenceList.remove(movedInPreviousPages + index);

					// Ενημέρωση της λίστας με τη νέα αναφορά.
					for (int i = movedInPreviousPages + index; i < newReferenceList
							.size(); i++) {
						newReferenceList.get(i).setOffset(
								newReferenceList.get(i).getOffset() - 1);
					} // end for

					// Οι διαγραφές δεν σταματούν, διότι μπορεί να υπάρχουν και
					// άλλες εγγραφές με το ίδιο δευτερεύον κλειδί.
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Η ανανεωμένη πλέον σελίδα γράφεται στον δίσκο.
			DiskHandler.writePage(page, currentLeaf.getPageNumber());

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια πεντάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής, μια λίστα με
		// τις εγγραφές και τις θέσεις των διεγραμένων εγγραφών και τρεις άλλες
		// λίστες που κρατούν στοιχεία για την ενημέρωση των αναφορών των
		// εγγραφών που μετακινήθηκαν μετά την διαγραφή.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;
		result[2] = recordsMoved;
		result[3] = oldReferenceList;
		result[4] = newReferenceList;

		return result;
	} // end method deleteAllLess

	/**
	 * Same as the <code>delete</code> method, only here it deletes all the records
	 * with a string key equal to the string key given to the parameter. Then
	 * updates the information to the primary B+ Tree, the references which were
	 * changed and the hard disk as well. This method is necessarily sequential.
	 * 
	 * @param key
	 *            <code>String</code> key according to which the deletions
	 *            will be done.
	 * @param keyIndex
	 *            The index of the key
	 * @return A <code>Result [5]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         deletion.
	 *         <li>A <code>LinkedList</code> object with the records and
	 *         positions of the deleted records.
	 *         <li> Three <code>LinkedList</code> objects which have
	 *         information to update the references of the records which were
	 *         moved after the deletion.
	 *         </ul>
	 */
	public Object[] delete(final String key, final int keyIndex) {
		// Για διαγραφή εγγραφών με βάση μια συμβολοσειρά - αναγκαστικά
		// σειριακή διαδικασία.

		Object[] result = new Object[5];
		LinkedList<Object[]> deleted = new LinkedList<Object[]>();
		LinkedList<Record> recordsMoved = new LinkedList<Record>();
		LinkedList<Reference> oldReferenceList = new LinkedList<Reference>();
		LinkedList<Reference> newReferenceList = new LinkedList<Reference>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		Page page;
		int movedInPreviousPages;
		int deletedInThisPage;
		while (currentLeaf != null) {
			// Ενημερώνεται το πεδίο που κρατά τον αριθμό των εγγραφών που
			// μετακινήθηκαν σε προηγούμενα φύλλα.
			movedInPreviousPages = recordsMoved.size();

			// Αρχικά δεν έχει γίνει κάποια διαγραφή σ' αυτή τη σελίδα.
			deletedInThisPage = 0;

			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Πριν αρχίσουν οι διαγραφές δημιουργούμε αναφορές για όλες τις
			// εγγραφές, όμοιες με αυτές που υπάρχουν στους δευτερεύοντες
			// καταλόγους.
			for (int j = 0; j < page.getPageLength(); j++) {
				recordsMoved.add(page.getRecord(j));

				Reference oldReference = new Reference(-1, currentLeaf
						.getPageNumber(), j);
				oldReferenceList.add(oldReference);

				// Αρχικά είναι όμοια με την oldReference, αλλά εάν προκύψει
				// διαγραφή στο φύλλο θα τροποποιηθεί.
				Reference newReference = new Reference(-1, currentLeaf
						.getPageNumber(), j);
				newReferenceList.add(newReference);
			} // end for

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if (((Char) page.getRecord(index).getKey(keyIndex)).toString()
						.equals(key)) {
					Object[] recordStatus = new Object[2];

					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					recordStatus[0] = page.getRecord(index);

					// Αποθηκευουμε τον αριθμό της σελίδας και τη θέση όπου
					// πραγματοποιήθηκε η διαγραφή.
					Reference newReference = new Reference(-1, currentLeaf
							.getPageNumber(), index + deletedInThisPage);
					recordStatus[1] = newReference;

					// Τα παραπάνω στοιχεία εισάγονται στη λίστα των διεγραμένων
					// που θα χρησιμοποιηθεί για την ενημέρωση των δευτερευόντων
					// καταλόγων.
					deleted.add(recordStatus);

					// Διαγράφουμε την εγγραφή απ' τη σελίδα.
					page.deleteRecord(index);

					// Ενημερώνεται το πεδίο που κρατά τον αριθμό των εγγραφών
					// που διαγράφησαν σ' αυτή τη σελίδα.
					deletedInThisPage++;

					// Η αναφορά αφαιρείται απ' αυτές τις λίστες, αφού υπάρχει
					// στη λίστα των διεγραμένων.
					recordsMoved.remove(movedInPreviousPages + index);
					oldReferenceList.remove(movedInPreviousPages + index);
					newReferenceList.remove(movedInPreviousPages + index);

					// Ενημέρωση της λίστας με τη νέα αναφορά.
					for (int i = movedInPreviousPages + index; i < newReferenceList
							.size(); i++) {
						newReferenceList.get(i).setOffset(
								newReferenceList.get(i).getOffset() - 1);
					} // end for

					// Οι διαγραφές δεν σταματούν, διότι μπορεί να υπάρχουν και
					// άλλες εγγραφές με το ίδιο δευτερεύον κλειδί.
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Η ανανεωμένη πλέον σελίδα γράφεται στον δίσκο.
			DiskHandler.writePage(page, currentLeaf.getPageNumber());

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια πεντάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της διαγραφής, μια λίστα με
		// τις εγγραφές και τις θέσεις των διεγραμένων εγγραφών και τρεις άλλες
		// λίστες που κρατούν στοιχεία για την ενημέρωση των αναφορών των
		// εγγραφών που μετακινήθηκαν μετά την διαγραφή.
		result[0] = deleted.size() == 0 ? false : true;
		result[1] = deleted;
		result[2] = recordsMoved;
		result[3] = oldReferenceList;
		result[4] = newReferenceList;

		return result;
	} // end method delete

	/**
	 * Finds a record (the one with key equal to <code>primaryKey</code>) and
	 * returns it.
	 * 
	 * @param primaryKey
	 *            The desired key.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the record that
	 *         was chosen.
	 *         </ul>
	 */

	public Object[] find(final int primaryKey) {
		// Για εύρεση ενός πρωτεύοντος κλειδιού.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Αναζήτηση για το φύλλο που αναφέρεται σε αυτό το κλειδί.
		PrimaryLeaf currentLeaf = this.search(primaryKey);

		// Φόρτωμα της αντίστοιχης σελίδας.
		Page page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
				this.bucketFactor, this.emptyRecord.clone());

		// Σάρωση των εγγραφών μέχρι να βρεθεί αυτή που μας ενδιαφέρει.
		for (int i = 0; i < page.getPageLength(); i++) {
			if (page.getRecord(i).getPrimaryKey() == primaryKey) {
				// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
				selected.add(page.getRecord(i));
				break;
			} // end if
		} // end for

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method find

	/**
	 * Same as the <code>find</code> method,only here it searches for all the
	 * records with key greater or equal to the one given to the parameter.
	 * 
	 * @param primaryKey
	 *            The desired key,
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the succeded of the
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */
	public Object[] findAllGreaterOrEqual(final int primaryKey) {
		// Για εύρεση όλων των πρωτευόντων κλειδιών με τιμή μεγαλύτερη ή ίση απ'
		// αυτή που δόθηκε.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Αναζήτηση για το φύλλο που αναφέρεται σε αυτό το κλειδί.
		PrimaryLeaf currentLeaf = this.search(primaryKey);

		// Φόρτωμα της αντίστοιχης σελίδας.
		Page page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
				this.bucketFactor, this.emptyRecord.clone());

		// Επειδή τα πρωτεύοντα κλειδιά είναι ταξινομημένα, βρίσκουμε το κλειδί
		// που μας ενδιαφέρει...
		int index = 0;
		while (index < page.getPageLength()
				&& page.getRecord(index).getPrimaryKey() < primaryKey) {
			// Εάν η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index++;
		} // end while

		// και στη συνέχεια κρατούμε όσα βρίσκονται δεξιά απ' αυτό.
		for (int i = page.getPageLength() - 1; i > index - 1; i--) {
			// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
			selected.addFirst(page.getRecord(i));
		} // end for

		// Μετά κρατούμε όλες τις εγγραφές σε όλες τις σελίδες που βρίσκονται
		// δεξιά τις προηγουμένης.
		currentLeaf = currentLeaf.getRightLeaf();
		while (currentLeaf != null) {
			// Φόρτωμα της σελίδας.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord.clone());

			// Σάρωση των εγγραφών από το τέλος προς την αρχή για να αποφευχθούν
			// οι παρενέργειες της αναταξινόμησης κατά τη διαγραφή.
			for (int i = 0; i < page.getPageLength(); i++) {
				// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
				selected.addLast(page.getRecord(i));
			} // end for

			// Μετακινούμαστε στην δεξιά σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllGreaterOrEqual

	/**
	 * Same as the <code>find</code> method, only here it searches for all the
	 * records with key lesser or equal to the one given to the parameter.
	 * 
	 * @param primaryKey
	 *            The desired key
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the succeded of the
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */
	public Object[] findAllLessOrEqual(final int primaryKey) {
		// Για εύρεση όλων των πρωτευόντων κλειδιών με τιμή μικρότερη ή ίση απ'
		// αυτή που δόθηκε.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Αναζήτηση για το φύλλο που αναφέρεται σε αυτό το κλειδί.
		PrimaryLeaf currentLeaf = this.search(primaryKey);

		// Φόρτωμα της αντίστοιχης σελίδας.
		Page page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
				this.bucketFactor, this.emptyRecord.clone());

		// Επειδή τα πρωτεύοντα κλειδιά είναι ταξινομημένα, βρίσκουμε το κλειδί
		// που μας ενδιαφέρει...
		int index = page.getPageLength() - 1;
		while (index > -1 && page.getRecord(index).getPrimaryKey() > primaryKey) {
			// Εάν η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index--;
		} // end while

		// και στη συνέχεια κρατούμε όσα βρίσκονται αριστερά απ' αυτό.
		for (int i = index; i > -1; i--) {
			// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
			selected.addFirst(page.getRecord(i));
		} // end for

		// Μετά κρατούμε όλες τις εγγραφές σε όλες τις σελίδες που βρίσκονται
		// αριστερά τις προηγουμένης.
		currentLeaf = currentLeaf.getLeftLeaf();

		while (currentLeaf != null) {
			// Φόρτωμα της σελίδας.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord.clone());

			// Σάρωση των εγγραφών από το τέλος προς την αρχή για να αποφευχθούν
			// οι παρενέργειες της αναταξινόμησης κατά τη διαγραφή.
			for (int i = page.getPageLength() - 1; i > -1; i--) {
				// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
				selected.addFirst(page.getRecord(i));
			} // end for

			// Μετακινούμαστε στην αριστερή σελίδα.
			currentLeaf = currentLeaf.getLeftLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllLessOrEqual

	/**
	 * Finds records after a call of <code>find</code>in a secondary index.
	 * 
	 * @param referenceList
	 *            The list with the references that we want to find
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */
	@SuppressWarnings("unchecked")
	public Object[] find(final LinkedList<Reference> referenceList) {
		// Για εύρεση πολλών εγγραφών - χρησιμοποιείται μετά από εύρεση σε
		// δευτερεύοντα κατάλογο.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Ταξινόμηση των αναφορών με βάση τους αριθμούς σελίδων τους.
		Collections.sort(referenceList, new Comparator<Reference>() {
			public int compare(Reference firstReference,
					Reference secondReference) {
				if (firstReference.getPageNumber() < secondReference
						.getPageNumber())
					return -1;
				else if (firstReference.getPageNumber() > secondReference
						.getPageNumber())
					return 1;
				else
					return 0;
			}
		});

		// Παίρνουμε όλες τις αναφορές μια - μια και βρίσκουμε την εγγραφή που
		// αντιστοιχεί σε κάθε μια απ' αυτές.
		int pageNumber = referenceList.get(0).getPageNumber();
		Page page = DiskHandler.loadPage(pageNumber, this.bucketFactor,
				this.emptyRecord);

		int index = 0;
		while (index < referenceList.size()) {
			if (pageNumber != referenceList.get(index).getPageNumber()) {
				// Φορτώνουμε την κατάλληλη σελίδα.
				page = DiskHandler.loadPage(referenceList.get(index)
						.getPageNumber(), this.bucketFactor, this.emptyRecord);

				pageNumber = referenceList.get(index).getPageNumber();
			} // end if

			// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
			selected.addLast(page.getRecord(referenceList.get(index)
					.getOffset()));

			// Προχωρούμε στην επομένη αναφορά.
			index++;
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method find

	/**
	 * Finds records using the <code>secondaryKey</code>. This
	 * method is necessarily sequential.
	 * 
	 * @param secondaryKey
	 *            The desired secondary key.
	 * @param keyIndex
	 *            The desired key's index.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */
	public Object[] find(final int secondaryKey, final int keyIndex) {
		// Για σειριακή εύρεση εγγραφών με βάση ένα δευτερεύον κλειδί -
		// αναγκαστικά σειριακή διαδικασία.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		Page page;
		while (currentLeaf != null) {
			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if (secondaryKey == (Integer) page.getRecord(index).getKey(
						keyIndex)) {
					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					selected.add(page.getRecord(index));
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method find

	/**
	 * Same as the <code>find</code> method, except that it finds all the records
	 * with key greater to the <code>secondaryKey</code>. This method
	 * is necessarily sequential.
	 * 
	 * @param secondaryKey
	 *            The desired secondary key.
	 * @param keyIndex
	 *            The desired key index.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */

	public Object[] findAllGreater(final int secondaryKey, final int keyIndex) {
		// Για σειριακή εύρεση όλων των εγγραφών που έχουν τιμή μεγαλύτερη απ'
		// το διδόμενο δευτερεύον κλειδί - αναγκαστικά σειριακή διαδικασία.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		Page page;
		while (currentLeaf != null) {
			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if ((Integer) page.getRecord(index).getKey(keyIndex) > secondaryKey) {
					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					selected.add(page.getRecord(index));
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllGreater

	/**
	 * Same as the <code>find</code> method,except that it finds all the records
	 * with key lesser to the <code>secondaryKey</code>. This method
	 * is necessarily sequential.
	 * 
	 * @param secondaryKey
	 *            The desired secondary key.
	 * @param keyIndex
	 *            The desired key index.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */
	public Object[] findAllLess(final int secondaryKey, final int keyIndex) {
		// Για σειριακή εύρεση όλων των εγγραφών που έχουν τιμή μικρότερη απ' το
		// διδόμενο δευτερεύον κλειδί - αναγκαστικά σειριακή διαδικασία.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		Page page;
		while (currentLeaf != null) {
			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if ((Integer) page.getRecord(index).getKey(keyIndex) < secondaryKey) {
					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					selected.add(page.getRecord(index));
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllLess

	/**
	 * Same as the <code>find</code> method, except that it finds all the records
	 * with a value equal to <code>key</code>. This
	 * method is necessarily sequential.
	 * 
	 * @param key
	 *            <code>String</code> key according to which, the deletions
	 *            will be done.
	 * @param keyIndex
	 *            The index of the key.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the succes of the
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */
	public Object[] find(final String key, final int keyIndex) {
		// Για εύρεση εγγραφών με βάση μια συμβολοσειρά - αναγκαστικά σειριακή
		// διαδικασία.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		while (currentLeaf != null) {
			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			Page page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if (((Char) page.getRecord(index).getKey(keyIndex)).toString()
						.equals(key)) {
					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					selected.add(page.getRecord(index));
					index++;
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method find

	/**
	 * Same as the <code>find</code> method, except that it finds all the records in
	 * the <u>open</u> range between the <code>firstPrimaryKey</code> and <code>lastPrimaryKey</code>.
	 * 
	 * @param firstPrimaryKey
	 *            The first key.
	 * @param lastPrimaryKey
	 *            The last key.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */

	public Object[] findAllInRange(final int firstPrimaryKey,
			final int lastPrimaryKey) {
		// Για εύρεση όλων των πρωτευόντων κλειδιών με τιμή που βρίσκεται στο
		// (ανοιχτό) διάστημα που δίδεται.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Αναζήτηση για το φύλλο που αναφέρεται σε αυτό το κλειδί.
		PrimaryLeaf currentLeaf = this.search(firstPrimaryKey);

		// Φόρτωμα της αντίστοιχης σελίδας.
		Page page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
				this.bucketFactor, this.emptyRecord.clone());

		// Επειδή τα πρωτεύοντα κλειδιά είναι ταξινομημένα, βρίσκουμε το κλειδί
		// που μας ενδιαφέρει...
		int index = 0;
		while (index < page.getPageLength()
				&& page.getRecord(index).getPrimaryKey() < firstPrimaryKey) {
			// Εάν η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε προχωρούμε
			// στην επομένη.
			index++;
		} // end while
		Record tmpRecord;
		// και στη συνέχεια κρατούμε όσα βρίσκονται δεξιά απ' αυτό.
		for (int i = (page.getRecord(index).getPrimaryKey() == firstPrimaryKey ? index + 1
				: index); i < page.getPageLength(); i++) {
			// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
			tmpRecord = page.getRecord(i);
			if (tmpRecord.getPrimaryKey() < lastPrimaryKey)
				selected.add(tmpRecord);
			else {
				result[0] = selected.size() == 0 ? false : true;
				result[1] = selected;

				return result;

			}
		} // end for

		// Μετά κρατούμε όλες τις εγγραφές σε όλες τις σελίδες που βρίσκονται
		// δεξιά τις προηγουμένης.
		currentLeaf = currentLeaf.getRightLeaf();

		while (currentLeaf != null) {
			// Φόρτωμα της σελίδας.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord.clone());

			for (int i = 0; i < page.getPageLength(); i++) {
				if (page.getRecord(i).getPrimaryKey() < lastPrimaryKey) {
					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					selected.add(page.getRecord(i));
				} // end if
				else {
					break;
				} // end else
			} // end for

			// Μετακινούμαστε στην δεξιά σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllInRange

	/**
	 * Same as the <code>find</code> method, except that it finds all the records in
	 * the <u>open</u> range between the <code>firstSecondaryKey</code> and <code>lastSecondaryKey</code>. This method is necessarily sequential.
	 * 
	 * @param firstSecondaryKey
	 *            The first key.
	 * @param lastSecondaryKey
	 *            The secondary key.
	 * @param keyIndex
	 *            The index of the key.
	 * @return A <code>Result [2]</code> array which contains: <br>
	 *         <ul>
	 *         <li>A <code>boolean</code> variable to verify the success of the
	 *         search proccess.
	 *         <li>A <code>LinkedList</code> object with the records that
	 *         were chosen.
	 *         </ul>
	 */

	public Object[] findAllInRange(final int firstSecondaryKey,
			final int lastSecondaryKey, final int keyIndex) {
		// Για σειριακή εύρεση όλων των εγγραφών που έχουν τιμή δευτερεύεοντος
		// κλειδιού στο (ανοιχτό) διάστημα που δίδεται - αναγκαστικά σειριακή
		// διαδικασία.

		Object[] result = new Object[2];
		LinkedList<Record> selected = new LinkedList<Record>();

		// Η έρευνα γίνεται σε όλες τις σελίδες καθώς το χαρακτηριστικό αυτό δεν
		// είναι μοναδικό.
		PrimaryLeaf currentLeaf = this.getFirstLeaf();

		Page page;
		while (currentLeaf != null) {
			// Φορτώνουμε τη σελίδα που αντιστοιχεί στο φύλλο αυτό.
			page = DiskHandler.loadPage(currentLeaf.getPageNumber(),
					this.bucketFactor, this.emptyRecord);

			// Έρευνα για τις εγγραφές με αυτό το κλειδί.
			int index = 0;
			while (index < page.getPageLength()) {
				if ((Integer) page.getRecord(index).getKey(keyIndex) > firstSecondaryKey
						&& (Integer) page.getRecord(index).getKey(keyIndex) < lastSecondaryKey) {
					// Αποθηκεύουμε προσωρινά την ίδια την εγγραφή.
					selected.add(page.getRecord(index));
				} // end if
				else {
					// Αφού η εγγραφή δεν έχει το κλειδί που θέλουμε, τότε
					// προχωρούμε στην επομένη.
					index++;
				} // end else
			} // end while

			// Εξετάζουμε την επομένη σελίδα.
			currentLeaf = currentLeaf.getRightLeaf();
		} // end while

		// Η μέθοδος επιστρέφει μια δυάδα, που αποτελείται από μια σημαία που
		// υποδεικνύει την επιτυχία ή την αποτυχία της εύρεσης και μια λίστα
		// με τις εγγραφές που επιλέγησαν.
		result[0] = selected.size() == 0 ? false : true;
		result[1] = selected;

		return result;
	} // end method findAllInRange

	/**
	 * Retrieves the first leaf.
	 * 
	 * @return The first <code>PrimaryLeaf</code>.
	 */
	public PrimaryLeaf getFirstLeaf() {
		return this.firstLeaf;
	} // end method getFirstLeaf

	/**
	 * Retrieves the bucket factor.
	 * 
	 * @return The bucket factor.
	 */
	public int getBucketFactor() {
		return this.bucketFactor;
	} // end method getBucketFactor

	/**
	 * Retrieves the empty record.
	 * 
	 * @return The empty record.
	 */
	public Record getEmptyRecordCopy() {
		return this.emptyRecord.clone();
	} // end method getEmptyRecordCopy
} // end class PrimaryBPlusTree
